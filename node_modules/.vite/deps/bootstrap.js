import { n as __export } from "./chunk-DUEDWNxO.js";
import { A as read, C as clippingParents, D as modifierPhases, E as main, F as variationPlacements, I as viewport, L as write, M as right, N as start, O as placements, P as top, S as bottom, T as left, _ as auto, a as offset_default, b as beforeRead, c as detectOverflow, d as arrow_default, f as isHTMLElement, g as afterWrite, h as afterRead, i as popperOffsets_default, j as reference, k as popper, l as eventListeners_default, m as afterMain, n as popperGenerator, o as hide_default, p as getNodeName, r as preventOverflow_default, s as flip_default, t as createPopper, u as computeStyles_default, v as basePlacements, w as end, x as beforeWrite, y as beforeMain } from "./createPopper-Bul6yP7N.js";

//#region node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
	var state = _ref.state;
	Object.keys(state.elements).forEach(function(name) {
		var style = state.styles[name] || {};
		var attributes = state.attributes[name] || {};
		var element = state.elements[name];
		if (!isHTMLElement(element) || !getNodeName(element)) return;
		Object.assign(element.style, style);
		Object.keys(attributes).forEach(function(name$1) {
			var value = attributes[name$1];
			if (value === false) element.removeAttribute(name$1);
			else element.setAttribute(name$1, value === true ? "" : value);
		});
	});
}
function effect(_ref2) {
	var state = _ref2.state;
	var initialStyles = {
		popper: {
			position: state.options.strategy,
			left: "0",
			top: "0",
			margin: "0"
		},
		arrow: { position: "absolute" },
		reference: {}
	};
	Object.assign(state.elements.popper.style, initialStyles.popper);
	state.styles = initialStyles;
	if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
	return function() {
		Object.keys(state.elements).forEach(function(name) {
			var element = state.elements[name];
			var attributes = state.attributes[name] || {};
			var style = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]).reduce(function(style$1, property) {
				style$1[property] = "";
				return style$1;
			}, {});
			if (!isHTMLElement(element) || !getNodeName(element)) return;
			Object.assign(element.style, style);
			Object.keys(attributes).forEach(function(attribute) {
				element.removeAttribute(attribute);
			});
		});
	};
}
var applyStyles_default = {
	name: "applyStyles",
	enabled: true,
	phase: "write",
	fn: applyStyles,
	effect,
	requires: ["computeStyles"]
};

//#endregion
//#region node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers$1 = [
	eventListeners_default,
	popperOffsets_default,
	computeStyles_default,
	applyStyles_default
];
var createPopper$2 = /* @__PURE__ */ popperGenerator({ defaultModifiers: defaultModifiers$1 });

//#endregion
//#region node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [
	eventListeners_default,
	popperOffsets_default,
	computeStyles_default,
	applyStyles_default,
	offset_default,
	flip_default,
	preventOverflow_default,
	arrow_default,
	hide_default
];
var createPopper$1 = /* @__PURE__ */ popperGenerator({ defaultModifiers });

//#endregion
//#region node_modules/@popperjs/core/lib/index.js
var lib_exports = /* @__PURE__ */ __export({
	afterMain: () => afterMain,
	afterRead: () => afterRead,
	afterWrite: () => afterWrite,
	applyStyles: () => applyStyles_default,
	arrow: () => arrow_default,
	auto: () => auto,
	basePlacements: () => basePlacements,
	beforeMain: () => beforeMain,
	beforeRead: () => beforeRead,
	beforeWrite: () => beforeWrite,
	bottom: () => bottom,
	clippingParents: () => clippingParents,
	computeStyles: () => computeStyles_default,
	createPopper: () => createPopper$1,
	createPopperBase: () => createPopper,
	createPopperLite: () => createPopper$2,
	detectOverflow: () => detectOverflow,
	end: () => end,
	eventListeners: () => eventListeners_default,
	flip: () => flip_default,
	hide: () => hide_default,
	left: () => left,
	main: () => main,
	modifierPhases: () => modifierPhases,
	offset: () => offset_default,
	placements: () => placements,
	popper: () => popper,
	popperGenerator: () => popperGenerator,
	popperOffsets: () => popperOffsets_default,
	preventOverflow: () => preventOverflow_default,
	read: () => read,
	reference: () => reference,
	right: () => right,
	start: () => start,
	top: () => top,
	variationPlacements: () => variationPlacements,
	viewport: () => viewport,
	write: () => write
});

//#endregion
//#region node_modules/bootstrap/dist/js/bootstrap.esm.js
/**
* --------------------------------------------------------------------------
* Bootstrap dom/data.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var elementMap = /* @__PURE__ */ new Map();
var Data = {
	set(element, key, instance) {
		if (!elementMap.has(element)) elementMap.set(element, /* @__PURE__ */ new Map());
		const instanceMap = elementMap.get(element);
		if (!instanceMap.has(key) && instanceMap.size !== 0) {
			console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
			return;
		}
		instanceMap.set(key, instance);
	},
	get(element, key) {
		if (elementMap.has(element)) return elementMap.get(element).get(key) || null;
		return null;
	},
	remove(element, key) {
		if (!elementMap.has(element)) return;
		const instanceMap = elementMap.get(element);
		instanceMap.delete(key);
		if (instanceMap.size === 0) elementMap.delete(element);
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap util/index.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
var MAX_UID = 1e6;
var MILLISECONDS_MULTIPLIER = 1e3;
var TRANSITION_END = "transitionend";
/**
* Properly escape IDs selectors to handle weird IDs
* @param {string} selector
* @returns {string}
*/
var parseSelector = (selector) => {
	if (selector && window.CSS && window.CSS.escape) selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
	return selector;
};
var toType = (object) => {
	if (object === null || object === void 0) return `${object}`;
	return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
* Public Util API
*/
var getUID = (prefix) => {
	do
		prefix += Math.floor(Math.random() * MAX_UID);
	while (document.getElementById(prefix));
	return prefix;
};
var getTransitionDurationFromElement = (element) => {
	if (!element) return 0;
	let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
	if (!Number.parseFloat(transitionDuration) && !Number.parseFloat(transitionDelay)) return 0;
	transitionDuration = transitionDuration.split(",")[0];
	transitionDelay = transitionDelay.split(",")[0];
	return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
var triggerTransitionEnd = (element) => {
	element.dispatchEvent(new Event(TRANSITION_END));
};
var isElement = (object) => {
	if (!object || typeof object !== "object") return false;
	if (typeof object.jquery !== "undefined") object = object[0];
	return typeof object.nodeType !== "undefined";
};
var getElement = (object) => {
	if (isElement(object)) return object.jquery ? object[0] : object;
	if (typeof object === "string" && object.length > 0) return document.querySelector(parseSelector(object));
	return null;
};
var isVisible = (element) => {
	if (!isElement(element) || element.getClientRects().length === 0) return false;
	const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
	const closedDetails = element.closest("details:not([open])");
	if (!closedDetails) return elementIsVisible;
	if (closedDetails !== element) {
		const summary = element.closest("summary");
		if (summary && summary.parentNode !== closedDetails) return false;
		if (summary === null) return false;
	}
	return elementIsVisible;
};
var isDisabled = (element) => {
	if (!element || element.nodeType !== Node.ELEMENT_NODE) return true;
	if (element.classList.contains("disabled")) return true;
	if (typeof element.disabled !== "undefined") return element.disabled;
	return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
var findShadowRoot = (element) => {
	if (!document.documentElement.attachShadow) return null;
	if (typeof element.getRootNode === "function") {
		const root = element.getRootNode();
		return root instanceof ShadowRoot ? root : null;
	}
	if (element instanceof ShadowRoot) return element;
	if (!element.parentNode) return null;
	return findShadowRoot(element.parentNode);
};
var noop = () => {};
/**
* Trick to restart an element's animation
*
* @param {HTMLElement} element
* @return void
*
* @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
*/
var reflow = (element) => {
	element.offsetHeight;
};
var getjQuery = () => {
	if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) return window.jQuery;
	return null;
};
var DOMContentLoadedCallbacks = [];
var onDOMContentLoaded = (callback) => {
	if (document.readyState === "loading") {
		if (!DOMContentLoadedCallbacks.length) document.addEventListener("DOMContentLoaded", () => {
			for (const callback$1 of DOMContentLoadedCallbacks) callback$1();
		});
		DOMContentLoadedCallbacks.push(callback);
	} else callback();
};
var isRTL = () => document.documentElement.dir === "rtl";
var defineJQueryPlugin = (plugin) => {
	onDOMContentLoaded(() => {
		const $ = getjQuery();
		/* istanbul ignore if */
		if ($) {
			const name = plugin.NAME;
			const JQUERY_NO_CONFLICT = $.fn[name];
			$.fn[name] = plugin.jQueryInterface;
			$.fn[name].Constructor = plugin;
			$.fn[name].noConflict = () => {
				$.fn[name] = JQUERY_NO_CONFLICT;
				return plugin.jQueryInterface;
			};
		}
	});
};
var execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
	return typeof possibleCallback === "function" ? possibleCallback.call(...args) : defaultValue;
};
var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
	if (!waitForTransition) {
		execute(callback);
		return;
	}
	const emulatedDuration = getTransitionDurationFromElement(transitionElement) + 5;
	let called = false;
	const handler = ({ target }) => {
		if (target !== transitionElement) return;
		called = true;
		transitionElement.removeEventListener(TRANSITION_END, handler);
		execute(callback);
	};
	transitionElement.addEventListener(TRANSITION_END, handler);
	setTimeout(() => {
		if (!called) triggerTransitionEnd(transitionElement);
	}, emulatedDuration);
};
/**
* Return the previous/next element of a list.
*
* @param {array} list    The list of elements
* @param activeElement   The active element
* @param shouldGetNext   Choose to get next or previous element
* @param isCycleAllowed
* @return {Element|elem} The proper element
*/
var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
	const listLength = list.length;
	let index = list.indexOf(activeElement);
	if (index === -1) return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
	index += shouldGetNext ? 1 : -1;
	if (isCycleAllowed) index = (index + listLength) % listLength;
	return list[Math.max(0, Math.min(index, listLength - 1))];
};
/**
* --------------------------------------------------------------------------
* Bootstrap dom/event-handler.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
var stripNameRegex = /\..*/;
var stripUidRegex = /::\d+$/;
var eventRegistry = {};
var uidEvent = 1;
var customEvents = {
	mouseenter: "mouseover",
	mouseleave: "mouseout"
};
var nativeEvents = new Set([
	"click",
	"dblclick",
	"mouseup",
	"mousedown",
	"contextmenu",
	"mousewheel",
	"DOMMouseScroll",
	"mouseover",
	"mouseout",
	"mousemove",
	"selectstart",
	"selectend",
	"keydown",
	"keypress",
	"keyup",
	"orientationchange",
	"touchstart",
	"touchmove",
	"touchend",
	"touchcancel",
	"pointerdown",
	"pointermove",
	"pointerup",
	"pointerleave",
	"pointercancel",
	"gesturestart",
	"gesturechange",
	"gestureend",
	"focus",
	"blur",
	"change",
	"reset",
	"select",
	"submit",
	"focusin",
	"focusout",
	"load",
	"unload",
	"beforeunload",
	"resize",
	"move",
	"DOMContentLoaded",
	"readystatechange",
	"error",
	"abort",
	"scroll"
]);
/**
* Private methods
*/
function makeEventUid(element, uid) {
	return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
	const uid = makeEventUid(element);
	element.uidEvent = uid;
	eventRegistry[uid] = eventRegistry[uid] || {};
	return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
	return function handler(event) {
		hydrateObj(event, { delegateTarget: element });
		if (handler.oneOff) EventHandler.off(element, event.type, fn);
		return fn.apply(element, [event]);
	};
}
function bootstrapDelegationHandler(element, selector, fn) {
	return function handler(event) {
		const domElements = element.querySelectorAll(selector);
		for (let { target } = event; target && target !== this; target = target.parentNode) for (const domElement of domElements) {
			if (domElement !== target) continue;
			hydrateObj(event, { delegateTarget: target });
			if (handler.oneOff) EventHandler.off(element, event.type, selector, fn);
			return fn.apply(target, [event]);
		}
	};
}
function findHandler(events, callable, delegationSelector = null) {
	return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
	const isDelegated = typeof handler === "string";
	const callable = isDelegated ? delegationFunction : handler || delegationFunction;
	let typeEvent = getTypeEvent(originalTypeEvent);
	if (!nativeEvents.has(typeEvent)) typeEvent = originalTypeEvent;
	return [
		isDelegated,
		callable,
		typeEvent
	];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
	if (typeof originalTypeEvent !== "string" || !element) return;
	let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
	if (originalTypeEvent in customEvents) {
		const wrapFunction = (fn$1) => {
			return function(event) {
				if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) return fn$1.call(this, event);
			};
		};
		callable = wrapFunction(callable);
	}
	const events = getElementEvents(element);
	const handlers = events[typeEvent] || (events[typeEvent] = {});
	const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
	if (previousFunction) {
		previousFunction.oneOff = previousFunction.oneOff && oneOff;
		return;
	}
	const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
	const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
	fn.delegationSelector = isDelegated ? handler : null;
	fn.callable = callable;
	fn.oneOff = oneOff;
	fn.uidEvent = uid;
	handlers[uid] = fn;
	element.addEventListener(typeEvent, fn, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
	const fn = findHandler(events[typeEvent], handler, delegationSelector);
	if (!fn) return;
	element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
	delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
	const storeElementEvent = events[typeEvent] || {};
	for (const [handlerKey, event] of Object.entries(storeElementEvent)) if (handlerKey.includes(namespace)) removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
}
function getTypeEvent(event) {
	event = event.replace(stripNameRegex, "");
	return customEvents[event] || event;
}
var EventHandler = {
	on(element, event, handler, delegationFunction) {
		addHandler(element, event, handler, delegationFunction, false);
	},
	one(element, event, handler, delegationFunction) {
		addHandler(element, event, handler, delegationFunction, true);
	},
	off(element, originalTypeEvent, handler, delegationFunction) {
		if (typeof originalTypeEvent !== "string" || !element) return;
		const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
		const inNamespace = typeEvent !== originalTypeEvent;
		const events = getElementEvents(element);
		const storeElementEvent = events[typeEvent] || {};
		const isNamespace = originalTypeEvent.startsWith(".");
		if (typeof callable !== "undefined") {
			if (!Object.keys(storeElementEvent).length) return;
			removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
			return;
		}
		if (isNamespace) for (const elementEvent of Object.keys(events)) removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
		for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
			const handlerKey = keyHandlers.replace(stripUidRegex, "");
			if (!inNamespace || originalTypeEvent.includes(handlerKey)) removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
		}
	},
	trigger(element, event, args) {
		if (typeof event !== "string" || !element) return null;
		const $ = getjQuery();
		const inNamespace = event !== getTypeEvent(event);
		let jQueryEvent = null;
		let bubbles = true;
		let nativeDispatch = true;
		let defaultPrevented = false;
		if (inNamespace && $) {
			jQueryEvent = $.Event(event, args);
			$(element).trigger(jQueryEvent);
			bubbles = !jQueryEvent.isPropagationStopped();
			nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
			defaultPrevented = jQueryEvent.isDefaultPrevented();
		}
		const evt = hydrateObj(new Event(event, {
			bubbles,
			cancelable: true
		}), args);
		if (defaultPrevented) evt.preventDefault();
		if (nativeDispatch) element.dispatchEvent(evt);
		if (evt.defaultPrevented && jQueryEvent) jQueryEvent.preventDefault();
		return evt;
	}
};
function hydrateObj(obj, meta = {}) {
	for (const [key, value] of Object.entries(meta)) try {
		obj[key] = value;
	} catch (_unused) {
		Object.defineProperty(obj, key, {
			configurable: true,
			get() {
				return value;
			}
		});
	}
	return obj;
}
/**
* --------------------------------------------------------------------------
* Bootstrap dom/manipulator.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
function normalizeData(value) {
	if (value === "true") return true;
	if (value === "false") return false;
	if (value === Number(value).toString()) return Number(value);
	if (value === "" || value === "null") return null;
	if (typeof value !== "string") return value;
	try {
		return JSON.parse(decodeURIComponent(value));
	} catch (_unused) {
		return value;
	}
}
function normalizeDataKey(key) {
	return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
}
var Manipulator = {
	setDataAttribute(element, key, value) {
		element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
	},
	removeDataAttribute(element, key) {
		element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
	},
	getDataAttributes(element) {
		if (!element) return {};
		const attributes = {};
		const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
		for (const key of bsKeys) {
			let pureKey = key.replace(/^bs/, "");
			pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
			attributes[pureKey] = normalizeData(element.dataset[key]);
		}
		return attributes;
	},
	getDataAttribute(element, key) {
		return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap util/config.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Class definition
*/
var Config = class {
	static get Default() {
		return {};
	}
	static get DefaultType() {
		return {};
	}
	static get NAME() {
		throw new Error("You have to implement the static method \"NAME\", for each component!");
	}
	_getConfig(config) {
		config = this._mergeConfigObj(config);
		config = this._configAfterMerge(config);
		this._typeCheckConfig(config);
		return config;
	}
	_configAfterMerge(config) {
		return config;
	}
	_mergeConfigObj(config, element) {
		const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, "config") : {};
		return {
			...this.constructor.Default,
			...typeof jsonConfig === "object" ? jsonConfig : {},
			...isElement(element) ? Manipulator.getDataAttributes(element) : {},
			...typeof config === "object" ? config : {}
		};
	}
	_typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
		for (const [property, expectedTypes] of Object.entries(configTypes)) {
			const value = config[property];
			const valueType = isElement(value) ? "element" : toType(value);
			if (!new RegExp(expectedTypes).test(valueType)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
		}
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap base-component.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var VERSION = "5.3.8";
/**
* Class definition
*/
var BaseComponent = class extends Config {
	constructor(element, config) {
		super();
		element = getElement(element);
		if (!element) return;
		this._element = element;
		this._config = this._getConfig(config);
		Data.set(this._element, this.constructor.DATA_KEY, this);
	}
	dispose() {
		Data.remove(this._element, this.constructor.DATA_KEY);
		EventHandler.off(this._element, this.constructor.EVENT_KEY);
		for (const propertyName of Object.getOwnPropertyNames(this)) this[propertyName] = null;
	}
	_queueCallback(callback, element, isAnimated = true) {
		executeAfterTransition(callback, element, isAnimated);
	}
	_getConfig(config) {
		config = this._mergeConfigObj(config, this._element);
		config = this._configAfterMerge(config);
		this._typeCheckConfig(config);
		return config;
	}
	static getInstance(element) {
		return Data.get(getElement(element), this.DATA_KEY);
	}
	static getOrCreateInstance(element, config = {}) {
		return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
	}
	static get VERSION() {
		return VERSION;
	}
	static get DATA_KEY() {
		return `bs.${this.NAME}`;
	}
	static get EVENT_KEY() {
		return `.${this.DATA_KEY}`;
	}
	static eventName(name) {
		return `${name}${this.EVENT_KEY}`;
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap dom/selector-engine.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
var getSelector = (element) => {
	let selector = element.getAttribute("data-bs-target");
	if (!selector || selector === "#") {
		let hrefAttribute = element.getAttribute("href");
		if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) return null;
		if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
		selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
	}
	return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
};
var SelectorEngine = {
	find(selector, element = document.documentElement) {
		return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
	},
	findOne(selector, element = document.documentElement) {
		return Element.prototype.querySelector.call(element, selector);
	},
	children(element, selector) {
		return [].concat(...element.children).filter((child) => child.matches(selector));
	},
	parents(element, selector) {
		const parents = [];
		let ancestor = element.parentNode.closest(selector);
		while (ancestor) {
			parents.push(ancestor);
			ancestor = ancestor.parentNode.closest(selector);
		}
		return parents;
	},
	prev(element, selector) {
		let previous = element.previousElementSibling;
		while (previous) {
			if (previous.matches(selector)) return [previous];
			previous = previous.previousElementSibling;
		}
		return [];
	},
	next(element, selector) {
		let next = element.nextElementSibling;
		while (next) {
			if (next.matches(selector)) return [next];
			next = next.nextElementSibling;
		}
		return [];
	},
	focusableChildren(element) {
		const focusables = [
			"a",
			"button",
			"input",
			"textarea",
			"select",
			"details",
			"[tabindex]",
			"[contenteditable=\"true\"]"
		].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
		return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
	},
	getSelectorFromElement(element) {
		const selector = getSelector(element);
		if (selector) return SelectorEngine.findOne(selector) ? selector : null;
		return null;
	},
	getElementFromSelector(element) {
		const selector = getSelector(element);
		return selector ? SelectorEngine.findOne(selector) : null;
	},
	getMultipleElementsFromSelector(element) {
		const selector = getSelector(element);
		return selector ? SelectorEngine.find(selector) : [];
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap util/component-functions.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
var enableDismissTrigger = (component, method = "hide") => {
	const clickEvent = `click.dismiss${component.EVENT_KEY}`;
	const name = component.NAME;
	EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
		if (["A", "AREA"].includes(this.tagName)) event.preventDefault();
		if (isDisabled(this)) return;
		const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
		component.getOrCreateInstance(target)[method]();
	});
};
/**
* --------------------------------------------------------------------------
* Bootstrap alert.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$f = "alert";
var EVENT_KEY$b = `.bs.alert`;
var EVENT_CLOSE = `close${EVENT_KEY$b}`;
var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
var CLASS_NAME_FADE$5 = "fade";
var CLASS_NAME_SHOW$8 = "show";
/**
* Class definition
*/
var Alert = class Alert extends BaseComponent {
	static get NAME() {
		return NAME$f;
	}
	close() {
		if (EventHandler.trigger(this._element, EVENT_CLOSE).defaultPrevented) return;
		this._element.classList.remove(CLASS_NAME_SHOW$8);
		const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
		this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
	}
	_destroyElement() {
		this._element.remove();
		EventHandler.trigger(this._element, EVENT_CLOSED);
		this.dispose();
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Alert.getOrCreateInstance(this);
			if (typeof config !== "string") return;
			if (data[config] === void 0 || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
			data[config](this);
		});
	}
};
/**
* Data API implementation
*/
enableDismissTrigger(Alert, "close");
/**
* jQuery
*/
defineJQueryPlugin(Alert);
/**
* --------------------------------------------------------------------------
* Bootstrap button.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$e = "button";
var EVENT_KEY$a = `.bs.button`;
var DATA_API_KEY$6 = ".data-api";
var CLASS_NAME_ACTIVE$3 = "active";
var SELECTOR_DATA_TOGGLE$5 = "[data-bs-toggle=\"button\"]";
var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
/**
* Class definition
*/
var Button = class Button extends BaseComponent {
	static get NAME() {
		return NAME$e;
	}
	toggle() {
		this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Button.getOrCreateInstance(this);
			if (config === "toggle") data[config]();
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
	event.preventDefault();
	const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
	Button.getOrCreateInstance(button).toggle();
});
/**
* jQuery
*/
defineJQueryPlugin(Button);
/**
* --------------------------------------------------------------------------
* Bootstrap util/swipe.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$d = "swipe";
var EVENT_KEY$9 = ".bs.swipe";
var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
var POINTER_TYPE_TOUCH = "touch";
var POINTER_TYPE_PEN = "pen";
var CLASS_NAME_POINTER_EVENT = "pointer-event";
var SWIPE_THRESHOLD = 40;
var Default$c = {
	endCallback: null,
	leftCallback: null,
	rightCallback: null
};
var DefaultType$c = {
	endCallback: "(function|null)",
	leftCallback: "(function|null)",
	rightCallback: "(function|null)"
};
/**
* Class definition
*/
var Swipe = class Swipe extends Config {
	constructor(element, config) {
		super();
		this._element = element;
		if (!element || !Swipe.isSupported()) return;
		this._config = this._getConfig(config);
		this._deltaX = 0;
		this._supportPointerEvents = Boolean(window.PointerEvent);
		this._initEvents();
	}
	static get Default() {
		return Default$c;
	}
	static get DefaultType() {
		return DefaultType$c;
	}
	static get NAME() {
		return NAME$d;
	}
	dispose() {
		EventHandler.off(this._element, EVENT_KEY$9);
	}
	_start(event) {
		if (!this._supportPointerEvents) {
			this._deltaX = event.touches[0].clientX;
			return;
		}
		if (this._eventIsPointerPenTouch(event)) this._deltaX = event.clientX;
	}
	_end(event) {
		if (this._eventIsPointerPenTouch(event)) this._deltaX = event.clientX - this._deltaX;
		this._handleSwipe();
		execute(this._config.endCallback);
	}
	_move(event) {
		this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
	}
	_handleSwipe() {
		const absDeltaX = Math.abs(this._deltaX);
		if (absDeltaX <= SWIPE_THRESHOLD) return;
		const direction = absDeltaX / this._deltaX;
		this._deltaX = 0;
		if (!direction) return;
		execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
	}
	_initEvents() {
		if (this._supportPointerEvents) {
			EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
			EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
			this._element.classList.add(CLASS_NAME_POINTER_EVENT);
		} else {
			EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
			EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
			EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
		}
	}
	_eventIsPointerPenTouch(event) {
		return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
	}
	static isSupported() {
		return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap carousel.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$c = "carousel";
var EVENT_KEY$8 = `.bs.carousel`;
var DATA_API_KEY$5 = ".data-api";
var ARROW_LEFT_KEY$1 = "ArrowLeft";
var ARROW_RIGHT_KEY$1 = "ArrowRight";
var TOUCHEVENT_COMPAT_WAIT = 500;
var ORDER_NEXT = "next";
var ORDER_PREV = "prev";
var DIRECTION_LEFT = "left";
var DIRECTION_RIGHT = "right";
var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
var EVENT_SLID = `slid${EVENT_KEY$8}`;
var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
var CLASS_NAME_CAROUSEL = "carousel";
var CLASS_NAME_ACTIVE$2 = "active";
var CLASS_NAME_SLIDE = "slide";
var CLASS_NAME_END = "carousel-item-end";
var CLASS_NAME_START = "carousel-item-start";
var CLASS_NAME_NEXT = "carousel-item-next";
var CLASS_NAME_PREV = "carousel-item-prev";
var SELECTOR_ACTIVE = ".active";
var SELECTOR_ITEM = ".carousel-item";
var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
var SELECTOR_ITEM_IMG = ".carousel-item img";
var SELECTOR_INDICATORS = ".carousel-indicators";
var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
var SELECTOR_DATA_RIDE = "[data-bs-ride=\"carousel\"]";
var KEY_TO_DIRECTION = {
	[ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
	[ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
var Default$b = {
	interval: 5e3,
	keyboard: true,
	pause: "hover",
	ride: false,
	touch: true,
	wrap: true
};
var DefaultType$b = {
	interval: "(number|boolean)",
	keyboard: "boolean",
	pause: "(string|boolean)",
	ride: "(boolean|string)",
	touch: "boolean",
	wrap: "boolean"
};
/**
* Class definition
*/
var Carousel = class Carousel extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._interval = null;
		this._activeElement = null;
		this._isSliding = false;
		this.touchTimeout = null;
		this._swipeHelper = null;
		this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
		this._addEventListeners();
		if (this._config.ride === CLASS_NAME_CAROUSEL) this.cycle();
	}
	static get Default() {
		return Default$b;
	}
	static get DefaultType() {
		return DefaultType$b;
	}
	static get NAME() {
		return NAME$c;
	}
	next() {
		this._slide(ORDER_NEXT);
	}
	nextWhenVisible() {
		if (!document.hidden && isVisible(this._element)) this.next();
	}
	prev() {
		this._slide(ORDER_PREV);
	}
	pause() {
		if (this._isSliding) triggerTransitionEnd(this._element);
		this._clearInterval();
	}
	cycle() {
		this._clearInterval();
		this._updateInterval();
		this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
	}
	_maybeEnableCycle() {
		if (!this._config.ride) return;
		if (this._isSliding) {
			EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
			return;
		}
		this.cycle();
	}
	to(index) {
		const items = this._getItems();
		if (index > items.length - 1 || index < 0) return;
		if (this._isSliding) {
			EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
			return;
		}
		const activeIndex = this._getItemIndex(this._getActive());
		if (activeIndex === index) return;
		const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
		this._slide(order, items[index]);
	}
	dispose() {
		if (this._swipeHelper) this._swipeHelper.dispose();
		super.dispose();
	}
	_configAfterMerge(config) {
		config.defaultInterval = config.interval;
		return config;
	}
	_addEventListeners() {
		if (this._config.keyboard) EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
		if (this._config.pause === "hover") {
			EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
			EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
		}
		if (this._config.touch && Swipe.isSupported()) this._addTouchEventListeners();
	}
	_addTouchEventListeners() {
		for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
		const endCallBack = () => {
			if (this._config.pause !== "hover") return;
			this.pause();
			if (this.touchTimeout) clearTimeout(this.touchTimeout);
			this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
		};
		const swipeConfig = {
			leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
			rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
			endCallback: endCallBack
		};
		this._swipeHelper = new Swipe(this._element, swipeConfig);
	}
	_keydown(event) {
		if (/input|textarea/i.test(event.target.tagName)) return;
		const direction = KEY_TO_DIRECTION[event.key];
		if (direction) {
			event.preventDefault();
			this._slide(this._directionToOrder(direction));
		}
	}
	_getItemIndex(element) {
		return this._getItems().indexOf(element);
	}
	_setActiveIndicatorElement(index) {
		if (!this._indicatorsElement) return;
		const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
		activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
		activeIndicator.removeAttribute("aria-current");
		const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
		if (newActiveIndicator) {
			newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
			newActiveIndicator.setAttribute("aria-current", "true");
		}
	}
	_updateInterval() {
		const element = this._activeElement || this._getActive();
		if (!element) return;
		const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
		this._config.interval = elementInterval || this._config.defaultInterval;
	}
	_slide(order, element = null) {
		if (this._isSliding) return;
		const activeElement = this._getActive();
		const isNext = order === ORDER_NEXT;
		const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
		if (nextElement === activeElement) return;
		const nextElementIndex = this._getItemIndex(nextElement);
		const triggerEvent = (eventName) => {
			return EventHandler.trigger(this._element, eventName, {
				relatedTarget: nextElement,
				direction: this._orderToDirection(order),
				from: this._getItemIndex(activeElement),
				to: nextElementIndex
			});
		};
		if (triggerEvent(EVENT_SLIDE).defaultPrevented) return;
		if (!activeElement || !nextElement) return;
		const isCycling = Boolean(this._interval);
		this.pause();
		this._isSliding = true;
		this._setActiveIndicatorElement(nextElementIndex);
		this._activeElement = nextElement;
		const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
		const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
		nextElement.classList.add(orderClassName);
		reflow(nextElement);
		activeElement.classList.add(directionalClassName);
		nextElement.classList.add(directionalClassName);
		const completeCallBack = () => {
			nextElement.classList.remove(directionalClassName, orderClassName);
			nextElement.classList.add(CLASS_NAME_ACTIVE$2);
			activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
			this._isSliding = false;
			triggerEvent(EVENT_SLID);
		};
		this._queueCallback(completeCallBack, activeElement, this._isAnimated());
		if (isCycling) this.cycle();
	}
	_isAnimated() {
		return this._element.classList.contains(CLASS_NAME_SLIDE);
	}
	_getActive() {
		return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
	}
	_getItems() {
		return SelectorEngine.find(SELECTOR_ITEM, this._element);
	}
	_clearInterval() {
		if (this._interval) {
			clearInterval(this._interval);
			this._interval = null;
		}
	}
	_directionToOrder(direction) {
		if (isRTL()) return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
		return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
	}
	_orderToDirection(order) {
		if (isRTL()) return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
		return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Carousel.getOrCreateInstance(this, config);
			if (typeof config === "number") {
				data.to(config);
				return;
			}
			if (typeof config === "string") {
				if (data[config] === void 0 || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
				data[config]();
			}
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
	const target = SelectorEngine.getElementFromSelector(this);
	if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) return;
	event.preventDefault();
	const carousel = Carousel.getOrCreateInstance(target);
	const slideIndex = this.getAttribute("data-bs-slide-to");
	if (slideIndex) {
		carousel.to(slideIndex);
		carousel._maybeEnableCycle();
		return;
	}
	if (Manipulator.getDataAttribute(this, "slide") === "next") {
		carousel.next();
		carousel._maybeEnableCycle();
		return;
	}
	carousel.prev();
	carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
	const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
	for (const carousel of carousels) Carousel.getOrCreateInstance(carousel);
});
/**
* jQuery
*/
defineJQueryPlugin(Carousel);
/**
* --------------------------------------------------------------------------
* Bootstrap collapse.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$b = "collapse";
var EVENT_KEY$7 = `.bs.collapse`;
var DATA_API_KEY$4 = ".data-api";
var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
var CLASS_NAME_SHOW$7 = "show";
var CLASS_NAME_COLLAPSE = "collapse";
var CLASS_NAME_COLLAPSING = "collapsing";
var CLASS_NAME_COLLAPSED = "collapsed";
var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
var WIDTH = "width";
var HEIGHT = "height";
var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
var SELECTOR_DATA_TOGGLE$4 = "[data-bs-toggle=\"collapse\"]";
var Default$a = {
	parent: null,
	toggle: true
};
var DefaultType$a = {
	parent: "(null|element)",
	toggle: "boolean"
};
/**
* Class definition
*/
var Collapse = class Collapse extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._isTransitioning = false;
		this._triggerArray = [];
		const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
		for (const elem of toggleList) {
			const selector = SelectorEngine.getSelectorFromElement(elem);
			const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
			if (selector !== null && filterElement.length) this._triggerArray.push(elem);
		}
		this._initializeChildren();
		if (!this._config.parent) this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
		if (this._config.toggle) this.toggle();
	}
	static get Default() {
		return Default$a;
	}
	static get DefaultType() {
		return DefaultType$a;
	}
	static get NAME() {
		return NAME$b;
	}
	toggle() {
		if (this._isShown()) this.hide();
		else this.show();
	}
	show() {
		if (this._isTransitioning || this._isShown()) return;
		let activeChildren = [];
		if (this._config.parent) activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, { toggle: false }));
		if (activeChildren.length && activeChildren[0]._isTransitioning) return;
		if (EventHandler.trigger(this._element, EVENT_SHOW$6).defaultPrevented) return;
		for (const activeInstance of activeChildren) activeInstance.hide();
		const dimension = this._getDimension();
		this._element.classList.remove(CLASS_NAME_COLLAPSE);
		this._element.classList.add(CLASS_NAME_COLLAPSING);
		this._element.style[dimension] = 0;
		this._addAriaAndCollapsedClass(this._triggerArray, true);
		this._isTransitioning = true;
		const complete = () => {
			this._isTransitioning = false;
			this._element.classList.remove(CLASS_NAME_COLLAPSING);
			this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
			this._element.style[dimension] = "";
			EventHandler.trigger(this._element, EVENT_SHOWN$6);
		};
		const scrollSize = `scroll${dimension[0].toUpperCase() + dimension.slice(1)}`;
		this._queueCallback(complete, this._element, true);
		this._element.style[dimension] = `${this._element[scrollSize]}px`;
	}
	hide() {
		if (this._isTransitioning || !this._isShown()) return;
		if (EventHandler.trigger(this._element, EVENT_HIDE$6).defaultPrevented) return;
		const dimension = this._getDimension();
		this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
		reflow(this._element);
		this._element.classList.add(CLASS_NAME_COLLAPSING);
		this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
		for (const trigger of this._triggerArray) {
			const element = SelectorEngine.getElementFromSelector(trigger);
			if (element && !this._isShown(element)) this._addAriaAndCollapsedClass([trigger], false);
		}
		this._isTransitioning = true;
		const complete = () => {
			this._isTransitioning = false;
			this._element.classList.remove(CLASS_NAME_COLLAPSING);
			this._element.classList.add(CLASS_NAME_COLLAPSE);
			EventHandler.trigger(this._element, EVENT_HIDDEN$6);
		};
		this._element.style[dimension] = "";
		this._queueCallback(complete, this._element, true);
	}
	_isShown(element = this._element) {
		return element.classList.contains(CLASS_NAME_SHOW$7);
	}
	_configAfterMerge(config) {
		config.toggle = Boolean(config.toggle);
		config.parent = getElement(config.parent);
		return config;
	}
	_getDimension() {
		return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
	}
	_initializeChildren() {
		if (!this._config.parent) return;
		const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
		for (const element of children) {
			const selected = SelectorEngine.getElementFromSelector(element);
			if (selected) this._addAriaAndCollapsedClass([element], this._isShown(selected));
		}
	}
	_getFirstLevelChildren(selector) {
		const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
		return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
	}
	_addAriaAndCollapsedClass(triggerArray, isOpen) {
		if (!triggerArray.length) return;
		for (const element of triggerArray) {
			element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
			element.setAttribute("aria-expanded", isOpen);
		}
	}
	static jQueryInterface(config) {
		const _config = {};
		if (typeof config === "string" && /show|hide/.test(config)) _config.toggle = false;
		return this.each(function() {
			const data = Collapse.getOrCreateInstance(this, _config);
			if (typeof config === "string") {
				if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
				data[config]();
			}
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
	if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") event.preventDefault();
	for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) Collapse.getOrCreateInstance(element, { toggle: false }).toggle();
});
/**
* jQuery
*/
defineJQueryPlugin(Collapse);
/**
* --------------------------------------------------------------------------
* Bootstrap dropdown.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$a = "dropdown";
var EVENT_KEY$6 = `.bs.dropdown`;
var DATA_API_KEY$3 = ".data-api";
var ESCAPE_KEY$2 = "Escape";
var TAB_KEY$1 = "Tab";
var ARROW_UP_KEY$1 = "ArrowUp";
var ARROW_DOWN_KEY$1 = "ArrowDown";
var RIGHT_MOUSE_BUTTON = 2;
var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
var CLASS_NAME_SHOW$6 = "show";
var CLASS_NAME_DROPUP = "dropup";
var CLASS_NAME_DROPEND = "dropend";
var CLASS_NAME_DROPSTART = "dropstart";
var CLASS_NAME_DROPUP_CENTER = "dropup-center";
var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
var SELECTOR_DATA_TOGGLE$3 = "[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)";
var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
var SELECTOR_MENU = ".dropdown-menu";
var SELECTOR_NAVBAR = ".navbar";
var SELECTOR_NAVBAR_NAV = ".navbar-nav";
var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
var PLACEMENT_TOPCENTER = "top";
var PLACEMENT_BOTTOMCENTER = "bottom";
var Default$9 = {
	autoClose: true,
	boundary: "clippingParents",
	display: "dynamic",
	offset: [0, 2],
	popperConfig: null,
	reference: "toggle"
};
var DefaultType$9 = {
	autoClose: "(boolean|string)",
	boundary: "(string|element)",
	display: "string",
	offset: "(array|string|function)",
	popperConfig: "(null|object|function)",
	reference: "(string|element|object)"
};
/**
* Class definition
*/
var Dropdown = class Dropdown extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._popper = null;
		this._parent = this._element.parentNode;
		this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
		this._inNavbar = this._detectNavbar();
	}
	static get Default() {
		return Default$9;
	}
	static get DefaultType() {
		return DefaultType$9;
	}
	static get NAME() {
		return NAME$a;
	}
	toggle() {
		return this._isShown() ? this.hide() : this.show();
	}
	show() {
		if (isDisabled(this._element) || this._isShown()) return;
		const relatedTarget = { relatedTarget: this._element };
		if (EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget).defaultPrevented) return;
		this._createPopper();
		if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) for (const element of [].concat(...document.body.children)) EventHandler.on(element, "mouseover", noop);
		this._element.focus();
		this._element.setAttribute("aria-expanded", true);
		this._menu.classList.add(CLASS_NAME_SHOW$6);
		this._element.classList.add(CLASS_NAME_SHOW$6);
		EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
	}
	hide() {
		if (isDisabled(this._element) || !this._isShown()) return;
		const relatedTarget = { relatedTarget: this._element };
		this._completeHide(relatedTarget);
	}
	dispose() {
		if (this._popper) this._popper.destroy();
		super.dispose();
	}
	update() {
		this._inNavbar = this._detectNavbar();
		if (this._popper) this._popper.update();
	}
	_completeHide(relatedTarget) {
		if (EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget).defaultPrevented) return;
		if ("ontouchstart" in document.documentElement) for (const element of [].concat(...document.body.children)) EventHandler.off(element, "mouseover", noop);
		if (this._popper) this._popper.destroy();
		this._menu.classList.remove(CLASS_NAME_SHOW$6);
		this._element.classList.remove(CLASS_NAME_SHOW$6);
		this._element.setAttribute("aria-expanded", "false");
		Manipulator.removeDataAttribute(this._menu, "popper");
		EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
	}
	_getConfig(config) {
		config = super._getConfig(config);
		if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
		return config;
	}
	_createPopper() {
		if (typeof lib_exports === "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
		let referenceElement = this._element;
		if (this._config.reference === "parent") referenceElement = this._parent;
		else if (isElement(this._config.reference)) referenceElement = getElement(this._config.reference);
		else if (typeof this._config.reference === "object") referenceElement = this._config.reference;
		const popperConfig = this._getPopperConfig();
		this._popper = createPopper$1(referenceElement, this._menu, popperConfig);
	}
	_isShown() {
		return this._menu.classList.contains(CLASS_NAME_SHOW$6);
	}
	_getPlacement() {
		const parentDropdown = this._parent;
		if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT;
		if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT;
		if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) return PLACEMENT_TOPCENTER;
		if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) return PLACEMENT_BOTTOMCENTER;
		const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
		if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
		return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
	}
	_detectNavbar() {
		return this._element.closest(SELECTOR_NAVBAR) !== null;
	}
	_getOffset() {
		const { offset } = this._config;
		if (typeof offset === "string") return offset.split(",").map((value) => Number.parseInt(value, 10));
		if (typeof offset === "function") return (popperData) => offset(popperData, this._element);
		return offset;
	}
	_getPopperConfig() {
		const defaultBsPopperConfig = {
			placement: this._getPlacement(),
			modifiers: [{
				name: "preventOverflow",
				options: { boundary: this._config.boundary }
			}, {
				name: "offset",
				options: { offset: this._getOffset() }
			}]
		};
		if (this._inNavbar || this._config.display === "static") {
			Manipulator.setDataAttribute(this._menu, "popper", "static");
			defaultBsPopperConfig.modifiers = [{
				name: "applyStyles",
				enabled: false
			}];
		}
		return {
			...defaultBsPopperConfig,
			...execute(this._config.popperConfig, [void 0, defaultBsPopperConfig])
		};
	}
	_selectMenuItem({ key, target }) {
		const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
		if (!items.length) return;
		getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Dropdown.getOrCreateInstance(this, config);
			if (typeof config !== "string") return;
			if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
			data[config]();
		});
	}
	static clearMenus(event) {
		if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) return;
		const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
		for (const toggle of openToggles) {
			const context = Dropdown.getInstance(toggle);
			if (!context || context._config.autoClose === false) continue;
			const composedPath = event.composedPath();
			const isMenuTarget = composedPath.includes(context._menu);
			if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) continue;
			if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) continue;
			const relatedTarget = { relatedTarget: context._element };
			if (event.type === "click") relatedTarget.clickEvent = event;
			context._completeHide(relatedTarget);
		}
	}
	static dataApiKeydownHandler(event) {
		const isInput = /input|textarea/i.test(event.target.tagName);
		const isEscapeEvent = event.key === ESCAPE_KEY$2;
		const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
		if (!isUpOrDownEvent && !isEscapeEvent) return;
		if (isInput && !isEscapeEvent) return;
		event.preventDefault();
		const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
		const instance = Dropdown.getOrCreateInstance(getToggleButton);
		if (isUpOrDownEvent) {
			event.stopPropagation();
			instance.show();
			instance._selectMenuItem(event);
			return;
		}
		if (instance._isShown()) {
			event.stopPropagation();
			instance.hide();
			getToggleButton.focus();
		}
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
	event.preventDefault();
	Dropdown.getOrCreateInstance(this).toggle();
});
/**
* jQuery
*/
defineJQueryPlugin(Dropdown);
/**
* --------------------------------------------------------------------------
* Bootstrap util/backdrop.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$9 = "backdrop";
var CLASS_NAME_FADE$4 = "fade";
var CLASS_NAME_SHOW$5 = "show";
var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
var Default$8 = {
	className: "modal-backdrop",
	clickCallback: null,
	isAnimated: false,
	isVisible: true,
	rootElement: "body"
};
var DefaultType$8 = {
	className: "string",
	clickCallback: "(function|null)",
	isAnimated: "boolean",
	isVisible: "boolean",
	rootElement: "(element|string)"
};
/**
* Class definition
*/
var Backdrop = class extends Config {
	constructor(config) {
		super();
		this._config = this._getConfig(config);
		this._isAppended = false;
		this._element = null;
	}
	static get Default() {
		return Default$8;
	}
	static get DefaultType() {
		return DefaultType$8;
	}
	static get NAME() {
		return NAME$9;
	}
	show(callback) {
		if (!this._config.isVisible) {
			execute(callback);
			return;
		}
		this._append();
		const element = this._getElement();
		if (this._config.isAnimated) reflow(element);
		element.classList.add(CLASS_NAME_SHOW$5);
		this._emulateAnimation(() => {
			execute(callback);
		});
	}
	hide(callback) {
		if (!this._config.isVisible) {
			execute(callback);
			return;
		}
		this._getElement().classList.remove(CLASS_NAME_SHOW$5);
		this._emulateAnimation(() => {
			this.dispose();
			execute(callback);
		});
	}
	dispose() {
		if (!this._isAppended) return;
		EventHandler.off(this._element, EVENT_MOUSEDOWN);
		this._element.remove();
		this._isAppended = false;
	}
	_getElement() {
		if (!this._element) {
			const backdrop = document.createElement("div");
			backdrop.className = this._config.className;
			if (this._config.isAnimated) backdrop.classList.add(CLASS_NAME_FADE$4);
			this._element = backdrop;
		}
		return this._element;
	}
	_configAfterMerge(config) {
		config.rootElement = getElement(config.rootElement);
		return config;
	}
	_append() {
		if (this._isAppended) return;
		const element = this._getElement();
		this._config.rootElement.append(element);
		EventHandler.on(element, EVENT_MOUSEDOWN, () => {
			execute(this._config.clickCallback);
		});
		this._isAppended = true;
	}
	_emulateAnimation(callback) {
		executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap util/focustrap.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$8 = "focustrap";
var EVENT_KEY$5 = `.bs.focustrap`;
var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
var TAB_KEY = "Tab";
var TAB_NAV_FORWARD = "forward";
var TAB_NAV_BACKWARD = "backward";
var Default$7 = {
	autofocus: true,
	trapElement: null
};
var DefaultType$7 = {
	autofocus: "boolean",
	trapElement: "element"
};
/**
* Class definition
*/
var FocusTrap = class extends Config {
	constructor(config) {
		super();
		this._config = this._getConfig(config);
		this._isActive = false;
		this._lastTabNavDirection = null;
	}
	static get Default() {
		return Default$7;
	}
	static get DefaultType() {
		return DefaultType$7;
	}
	static get NAME() {
		return NAME$8;
	}
	activate() {
		if (this._isActive) return;
		if (this._config.autofocus) this._config.trapElement.focus();
		EventHandler.off(document, EVENT_KEY$5);
		EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
		EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
		this._isActive = true;
	}
	deactivate() {
		if (!this._isActive) return;
		this._isActive = false;
		EventHandler.off(document, EVENT_KEY$5);
	}
	_handleFocusin(event) {
		const { trapElement } = this._config;
		if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) return;
		const elements = SelectorEngine.focusableChildren(trapElement);
		if (elements.length === 0) trapElement.focus();
		else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) elements[elements.length - 1].focus();
		else elements[0].focus();
	}
	_handleKeydown(event) {
		if (event.key !== TAB_KEY) return;
		this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap util/scrollBar.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
var SELECTOR_STICKY_CONTENT = ".sticky-top";
var PROPERTY_PADDING = "padding-right";
var PROPERTY_MARGIN = "margin-right";
/**
* Class definition
*/
var ScrollBarHelper = class {
	constructor() {
		this._element = document.body;
	}
	getWidth() {
		const documentWidth = document.documentElement.clientWidth;
		return Math.abs(window.innerWidth - documentWidth);
	}
	hide() {
		const width = this.getWidth();
		this._disableOverFlow();
		this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
		this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
		this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
	}
	reset() {
		this._resetElementAttributes(this._element, "overflow");
		this._resetElementAttributes(this._element, PROPERTY_PADDING);
		this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
		this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
	}
	isOverflowing() {
		return this.getWidth() > 0;
	}
	_disableOverFlow() {
		this._saveInitialAttribute(this._element, "overflow");
		this._element.style.overflow = "hidden";
	}
	_setElementAttributes(selector, styleProperty, callback) {
		const scrollbarWidth = this.getWidth();
		const manipulationCallBack = (element) => {
			if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) return;
			this._saveInitialAttribute(element, styleProperty);
			const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
			element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
		};
		this._applyManipulationCallback(selector, manipulationCallBack);
	}
	_saveInitialAttribute(element, styleProperty) {
		const actualValue = element.style.getPropertyValue(styleProperty);
		if (actualValue) Manipulator.setDataAttribute(element, styleProperty, actualValue);
	}
	_resetElementAttributes(selector, styleProperty) {
		const manipulationCallBack = (element) => {
			const value = Manipulator.getDataAttribute(element, styleProperty);
			if (value === null) {
				element.style.removeProperty(styleProperty);
				return;
			}
			Manipulator.removeDataAttribute(element, styleProperty);
			element.style.setProperty(styleProperty, value);
		};
		this._applyManipulationCallback(selector, manipulationCallBack);
	}
	_applyManipulationCallback(selector, callBack) {
		if (isElement(selector)) {
			callBack(selector);
			return;
		}
		for (const sel of SelectorEngine.find(selector, this._element)) callBack(sel);
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap modal.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$7 = "modal";
var EVENT_KEY$4 = `.bs.modal`;
var DATA_API_KEY$2 = ".data-api";
var ESCAPE_KEY$1 = "Escape";
var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
var CLASS_NAME_OPEN = "modal-open";
var CLASS_NAME_FADE$3 = "fade";
var CLASS_NAME_SHOW$4 = "show";
var CLASS_NAME_STATIC = "modal-static";
var OPEN_SELECTOR$1 = ".modal.show";
var SELECTOR_DIALOG = ".modal-dialog";
var SELECTOR_MODAL_BODY = ".modal-body";
var SELECTOR_DATA_TOGGLE$2 = "[data-bs-toggle=\"modal\"]";
var Default$6 = {
	backdrop: true,
	focus: true,
	keyboard: true
};
var DefaultType$6 = {
	backdrop: "(boolean|string)",
	focus: "boolean",
	keyboard: "boolean"
};
/**
* Class definition
*/
var Modal = class Modal extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
		this._backdrop = this._initializeBackDrop();
		this._focustrap = this._initializeFocusTrap();
		this._isShown = false;
		this._isTransitioning = false;
		this._scrollBar = new ScrollBarHelper();
		this._addEventListeners();
	}
	static get Default() {
		return Default$6;
	}
	static get DefaultType() {
		return DefaultType$6;
	}
	static get NAME() {
		return NAME$7;
	}
	toggle(relatedTarget) {
		return this._isShown ? this.hide() : this.show(relatedTarget);
	}
	show(relatedTarget) {
		if (this._isShown || this._isTransitioning) return;
		if (EventHandler.trigger(this._element, EVENT_SHOW$4, { relatedTarget }).defaultPrevented) return;
		this._isShown = true;
		this._isTransitioning = true;
		this._scrollBar.hide();
		document.body.classList.add(CLASS_NAME_OPEN);
		this._adjustDialog();
		this._backdrop.show(() => this._showElement(relatedTarget));
	}
	hide() {
		if (!this._isShown || this._isTransitioning) return;
		if (EventHandler.trigger(this._element, EVENT_HIDE$4).defaultPrevented) return;
		this._isShown = false;
		this._isTransitioning = true;
		this._focustrap.deactivate();
		this._element.classList.remove(CLASS_NAME_SHOW$4);
		this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
	}
	dispose() {
		EventHandler.off(window, EVENT_KEY$4);
		EventHandler.off(this._dialog, EVENT_KEY$4);
		this._backdrop.dispose();
		this._focustrap.deactivate();
		super.dispose();
	}
	handleUpdate() {
		this._adjustDialog();
	}
	_initializeBackDrop() {
		return new Backdrop({
			isVisible: Boolean(this._config.backdrop),
			isAnimated: this._isAnimated()
		});
	}
	_initializeFocusTrap() {
		return new FocusTrap({ trapElement: this._element });
	}
	_showElement(relatedTarget) {
		if (!document.body.contains(this._element)) document.body.append(this._element);
		this._element.style.display = "block";
		this._element.removeAttribute("aria-hidden");
		this._element.setAttribute("aria-modal", true);
		this._element.setAttribute("role", "dialog");
		this._element.scrollTop = 0;
		const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
		if (modalBody) modalBody.scrollTop = 0;
		reflow(this._element);
		this._element.classList.add(CLASS_NAME_SHOW$4);
		const transitionComplete = () => {
			if (this._config.focus) this._focustrap.activate();
			this._isTransitioning = false;
			EventHandler.trigger(this._element, EVENT_SHOWN$4, { relatedTarget });
		};
		this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
	}
	_addEventListeners() {
		EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
			if (event.key !== ESCAPE_KEY$1) return;
			if (this._config.keyboard) {
				this.hide();
				return;
			}
			this._triggerBackdropTransition();
		});
		EventHandler.on(window, EVENT_RESIZE$1, () => {
			if (this._isShown && !this._isTransitioning) this._adjustDialog();
		});
		EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
			EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
				if (this._element !== event.target || this._element !== event2.target) return;
				if (this._config.backdrop === "static") {
					this._triggerBackdropTransition();
					return;
				}
				if (this._config.backdrop) this.hide();
			});
		});
	}
	_hideModal() {
		this._element.style.display = "none";
		this._element.setAttribute("aria-hidden", true);
		this._element.removeAttribute("aria-modal");
		this._element.removeAttribute("role");
		this._isTransitioning = false;
		this._backdrop.hide(() => {
			document.body.classList.remove(CLASS_NAME_OPEN);
			this._resetAdjustments();
			this._scrollBar.reset();
			EventHandler.trigger(this._element, EVENT_HIDDEN$4);
		});
	}
	_isAnimated() {
		return this._element.classList.contains(CLASS_NAME_FADE$3);
	}
	_triggerBackdropTransition() {
		if (EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1).defaultPrevented) return;
		const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
		const initialOverflowY = this._element.style.overflowY;
		if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) return;
		if (!isModalOverflowing) this._element.style.overflowY = "hidden";
		this._element.classList.add(CLASS_NAME_STATIC);
		this._queueCallback(() => {
			this._element.classList.remove(CLASS_NAME_STATIC);
			this._queueCallback(() => {
				this._element.style.overflowY = initialOverflowY;
			}, this._dialog);
		}, this._dialog);
		this._element.focus();
	}
	/**
	* The following methods are used to handle overflowing modals
	*/
	_adjustDialog() {
		const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
		const scrollbarWidth = this._scrollBar.getWidth();
		const isBodyOverflowing = scrollbarWidth > 0;
		if (isBodyOverflowing && !isModalOverflowing) {
			const property = isRTL() ? "paddingLeft" : "paddingRight";
			this._element.style[property] = `${scrollbarWidth}px`;
		}
		if (!isBodyOverflowing && isModalOverflowing) {
			const property = isRTL() ? "paddingRight" : "paddingLeft";
			this._element.style[property] = `${scrollbarWidth}px`;
		}
	}
	_resetAdjustments() {
		this._element.style.paddingLeft = "";
		this._element.style.paddingRight = "";
	}
	static jQueryInterface(config, relatedTarget) {
		return this.each(function() {
			const data = Modal.getOrCreateInstance(this, config);
			if (typeof config !== "string") return;
			if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
			data[config](relatedTarget);
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
	const target = SelectorEngine.getElementFromSelector(this);
	if (["A", "AREA"].includes(this.tagName)) event.preventDefault();
	EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
		if (showEvent.defaultPrevented) return;
		EventHandler.one(target, EVENT_HIDDEN$4, () => {
			if (isVisible(this)) this.focus();
		});
	});
	const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
	if (alreadyOpen) Modal.getInstance(alreadyOpen).hide();
	Modal.getOrCreateInstance(target).toggle(this);
});
enableDismissTrigger(Modal);
/**
* jQuery
*/
defineJQueryPlugin(Modal);
/**
* --------------------------------------------------------------------------
* Bootstrap offcanvas.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$6 = "offcanvas";
var EVENT_KEY$3 = `.bs.offcanvas`;
var DATA_API_KEY$1 = ".data-api";
var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
var ESCAPE_KEY = "Escape";
var CLASS_NAME_SHOW$3 = "show";
var CLASS_NAME_SHOWING$1 = "showing";
var CLASS_NAME_HIDING = "hiding";
var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
var OPEN_SELECTOR = ".offcanvas.show";
var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
var SELECTOR_DATA_TOGGLE$1 = "[data-bs-toggle=\"offcanvas\"]";
var Default$5 = {
	backdrop: true,
	keyboard: true,
	scroll: false
};
var DefaultType$5 = {
	backdrop: "(boolean|string)",
	keyboard: "boolean",
	scroll: "boolean"
};
/**
* Class definition
*/
var Offcanvas = class Offcanvas extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._isShown = false;
		this._backdrop = this._initializeBackDrop();
		this._focustrap = this._initializeFocusTrap();
		this._addEventListeners();
	}
	static get Default() {
		return Default$5;
	}
	static get DefaultType() {
		return DefaultType$5;
	}
	static get NAME() {
		return NAME$6;
	}
	toggle(relatedTarget) {
		return this._isShown ? this.hide() : this.show(relatedTarget);
	}
	show(relatedTarget) {
		if (this._isShown) return;
		if (EventHandler.trigger(this._element, EVENT_SHOW$3, { relatedTarget }).defaultPrevented) return;
		this._isShown = true;
		this._backdrop.show();
		if (!this._config.scroll) new ScrollBarHelper().hide();
		this._element.setAttribute("aria-modal", true);
		this._element.setAttribute("role", "dialog");
		this._element.classList.add(CLASS_NAME_SHOWING$1);
		const completeCallBack = () => {
			if (!this._config.scroll || this._config.backdrop) this._focustrap.activate();
			this._element.classList.add(CLASS_NAME_SHOW$3);
			this._element.classList.remove(CLASS_NAME_SHOWING$1);
			EventHandler.trigger(this._element, EVENT_SHOWN$3, { relatedTarget });
		};
		this._queueCallback(completeCallBack, this._element, true);
	}
	hide() {
		if (!this._isShown) return;
		if (EventHandler.trigger(this._element, EVENT_HIDE$3).defaultPrevented) return;
		this._focustrap.deactivate();
		this._element.blur();
		this._isShown = false;
		this._element.classList.add(CLASS_NAME_HIDING);
		this._backdrop.hide();
		const completeCallback = () => {
			this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
			this._element.removeAttribute("aria-modal");
			this._element.removeAttribute("role");
			if (!this._config.scroll) new ScrollBarHelper().reset();
			EventHandler.trigger(this._element, EVENT_HIDDEN$3);
		};
		this._queueCallback(completeCallback, this._element, true);
	}
	dispose() {
		this._backdrop.dispose();
		this._focustrap.deactivate();
		super.dispose();
	}
	_initializeBackDrop() {
		const clickCallback = () => {
			if (this._config.backdrop === "static") {
				EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
				return;
			}
			this.hide();
		};
		const isVisible$1 = Boolean(this._config.backdrop);
		return new Backdrop({
			className: CLASS_NAME_BACKDROP,
			isVisible: isVisible$1,
			isAnimated: true,
			rootElement: this._element.parentNode,
			clickCallback: isVisible$1 ? clickCallback : null
		});
	}
	_initializeFocusTrap() {
		return new FocusTrap({ trapElement: this._element });
	}
	_addEventListeners() {
		EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
			if (event.key !== ESCAPE_KEY) return;
			if (this._config.keyboard) {
				this.hide();
				return;
			}
			EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
		});
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Offcanvas.getOrCreateInstance(this, config);
			if (typeof config !== "string") return;
			if (data[config] === void 0 || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
			data[config](this);
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
	const target = SelectorEngine.getElementFromSelector(this);
	if (["A", "AREA"].includes(this.tagName)) event.preventDefault();
	if (isDisabled(this)) return;
	EventHandler.one(target, EVENT_HIDDEN$3, () => {
		if (isVisible(this)) this.focus();
	});
	const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
	if (alreadyOpen && alreadyOpen !== target) Offcanvas.getInstance(alreadyOpen).hide();
	Offcanvas.getOrCreateInstance(target).toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
	for (const selector of SelectorEngine.find(OPEN_SELECTOR)) Offcanvas.getOrCreateInstance(selector).show();
});
EventHandler.on(window, EVENT_RESIZE, () => {
	for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) if (getComputedStyle(element).position !== "fixed") Offcanvas.getOrCreateInstance(element).hide();
});
enableDismissTrigger(Offcanvas);
/**
* jQuery
*/
defineJQueryPlugin(Offcanvas);
/**
* --------------------------------------------------------------------------
* Bootstrap util/sanitizer.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var DefaultAllowlist = {
	"*": [
		"class",
		"dir",
		"id",
		"lang",
		"role",
		ARIA_ATTRIBUTE_PATTERN
	],
	a: [
		"target",
		"href",
		"title",
		"rel"
	],
	area: [],
	b: [],
	br: [],
	col: [],
	code: [],
	dd: [],
	div: [],
	dl: [],
	dt: [],
	em: [],
	hr: [],
	h1: [],
	h2: [],
	h3: [],
	h4: [],
	h5: [],
	h6: [],
	i: [],
	img: [
		"src",
		"srcset",
		"alt",
		"title",
		"width",
		"height"
	],
	li: [],
	ol: [],
	p: [],
	pre: [],
	s: [],
	small: [],
	span: [],
	sub: [],
	sup: [],
	strong: [],
	u: [],
	ul: []
};
var uriAttributes = new Set([
	"background",
	"cite",
	"href",
	"itemtype",
	"longdesc",
	"poster",
	"src",
	"xlink:href"
]);
/**
* A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
* contexts.
*
* Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
*/
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
var allowedAttribute = (attribute, allowedAttributeList) => {
	const attributeName = attribute.nodeName.toLowerCase();
	if (allowedAttributeList.includes(attributeName)) {
		if (uriAttributes.has(attributeName)) return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
		return true;
	}
	return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
	if (!unsafeHtml.length) return unsafeHtml;
	if (sanitizeFunction && typeof sanitizeFunction === "function") return sanitizeFunction(unsafeHtml);
	const createdDocument = new window.DOMParser().parseFromString(unsafeHtml, "text/html");
	const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
	for (const element of elements) {
		const elementName = element.nodeName.toLowerCase();
		if (!Object.keys(allowList).includes(elementName)) {
			element.remove();
			continue;
		}
		const attributeList = [].concat(...element.attributes);
		const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
		for (const attribute of attributeList) if (!allowedAttribute(attribute, allowedAttributes)) element.removeAttribute(attribute.nodeName);
	}
	return createdDocument.body.innerHTML;
}
/**
* --------------------------------------------------------------------------
* Bootstrap util/template-factory.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$5 = "TemplateFactory";
var Default$4 = {
	allowList: DefaultAllowlist,
	content: {},
	extraClass: "",
	html: false,
	sanitize: true,
	sanitizeFn: null,
	template: "<div></div>"
};
var DefaultType$4 = {
	allowList: "object",
	content: "object",
	extraClass: "(string|function)",
	html: "boolean",
	sanitize: "boolean",
	sanitizeFn: "(null|function)",
	template: "string"
};
var DefaultContentType = {
	entry: "(string|element|function|null)",
	selector: "(string|element)"
};
/**
* Class definition
*/
var TemplateFactory = class extends Config {
	constructor(config) {
		super();
		this._config = this._getConfig(config);
	}
	static get Default() {
		return Default$4;
	}
	static get DefaultType() {
		return DefaultType$4;
	}
	static get NAME() {
		return NAME$5;
	}
	getContent() {
		return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
	}
	hasContent() {
		return this.getContent().length > 0;
	}
	changeContent(content) {
		this._checkContent(content);
		this._config.content = {
			...this._config.content,
			...content
		};
		return this;
	}
	toHtml() {
		const templateWrapper = document.createElement("div");
		templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
		for (const [selector, text] of Object.entries(this._config.content)) this._setContent(templateWrapper, text, selector);
		const template = templateWrapper.children[0];
		const extraClass = this._resolvePossibleFunction(this._config.extraClass);
		if (extraClass) template.classList.add(...extraClass.split(" "));
		return template;
	}
	_typeCheckConfig(config) {
		super._typeCheckConfig(config);
		this._checkContent(config.content);
	}
	_checkContent(arg) {
		for (const [selector, content] of Object.entries(arg)) super._typeCheckConfig({
			selector,
			entry: content
		}, DefaultContentType);
	}
	_setContent(template, content, selector) {
		const templateElement = SelectorEngine.findOne(selector, template);
		if (!templateElement) return;
		content = this._resolvePossibleFunction(content);
		if (!content) {
			templateElement.remove();
			return;
		}
		if (isElement(content)) {
			this._putElementInTemplate(getElement(content), templateElement);
			return;
		}
		if (this._config.html) {
			templateElement.innerHTML = this._maybeSanitize(content);
			return;
		}
		templateElement.textContent = content;
	}
	_maybeSanitize(arg) {
		return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
	}
	_resolvePossibleFunction(arg) {
		return execute(arg, [void 0, this]);
	}
	_putElementInTemplate(element, templateElement) {
		if (this._config.html) {
			templateElement.innerHTML = "";
			templateElement.append(element);
			return;
		}
		templateElement.textContent = element.textContent;
	}
};
/**
* --------------------------------------------------------------------------
* Bootstrap tooltip.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$4 = "tooltip";
var DISALLOWED_ATTRIBUTES = new Set([
	"sanitize",
	"allowList",
	"sanitizeFn"
]);
var CLASS_NAME_FADE$2 = "fade";
var CLASS_NAME_MODAL = "modal";
var CLASS_NAME_SHOW$2 = "show";
var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
var EVENT_MODAL_HIDE = "hide.bs.modal";
var TRIGGER_HOVER = "hover";
var TRIGGER_FOCUS = "focus";
var TRIGGER_CLICK = "click";
var TRIGGER_MANUAL = "manual";
var EVENT_HIDE$2 = "hide";
var EVENT_HIDDEN$2 = "hidden";
var EVENT_SHOW$2 = "show";
var EVENT_SHOWN$2 = "shown";
var EVENT_INSERTED = "inserted";
var EVENT_CLICK$1 = "click";
var EVENT_FOCUSIN$1 = "focusin";
var EVENT_FOCUSOUT$1 = "focusout";
var EVENT_MOUSEENTER = "mouseenter";
var EVENT_MOUSELEAVE = "mouseleave";
var AttachmentMap = {
	AUTO: "auto",
	TOP: "top",
	RIGHT: isRTL() ? "left" : "right",
	BOTTOM: "bottom",
	LEFT: isRTL() ? "right" : "left"
};
var Default$3 = {
	allowList: DefaultAllowlist,
	animation: true,
	boundary: "clippingParents",
	container: false,
	customClass: "",
	delay: 0,
	fallbackPlacements: [
		"top",
		"right",
		"bottom",
		"left"
	],
	html: false,
	offset: [0, 6],
	placement: "top",
	popperConfig: null,
	sanitize: true,
	sanitizeFn: null,
	selector: false,
	template: "<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>",
	title: "",
	trigger: "hover focus"
};
var DefaultType$3 = {
	allowList: "object",
	animation: "boolean",
	boundary: "(string|element)",
	container: "(string|element|boolean)",
	customClass: "(string|function)",
	delay: "(number|object)",
	fallbackPlacements: "array",
	html: "boolean",
	offset: "(array|string|function)",
	placement: "(string|function)",
	popperConfig: "(null|object|function)",
	sanitize: "boolean",
	sanitizeFn: "(null|function)",
	selector: "(string|boolean)",
	template: "string",
	title: "(string|element|function)",
	trigger: "string"
};
/**
* Class definition
*/
var Tooltip = class Tooltip extends BaseComponent {
	constructor(element, config) {
		if (typeof lib_exports === "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
		super(element, config);
		this._isEnabled = true;
		this._timeout = 0;
		this._isHovered = null;
		this._activeTrigger = {};
		this._popper = null;
		this._templateFactory = null;
		this._newContent = null;
		this.tip = null;
		this._setListeners();
		if (!this._config.selector) this._fixTitle();
	}
	static get Default() {
		return Default$3;
	}
	static get DefaultType() {
		return DefaultType$3;
	}
	static get NAME() {
		return NAME$4;
	}
	enable() {
		this._isEnabled = true;
	}
	disable() {
		this._isEnabled = false;
	}
	toggleEnabled() {
		this._isEnabled = !this._isEnabled;
	}
	toggle() {
		if (!this._isEnabled) return;
		if (this._isShown()) {
			this._leave();
			return;
		}
		this._enter();
	}
	dispose() {
		clearTimeout(this._timeout);
		EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
		if (this._element.getAttribute("data-bs-original-title")) this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
		this._disposePopper();
		super.dispose();
	}
	show() {
		if (this._element.style.display === "none") throw new Error("Please use show on visible elements");
		if (!(this._isWithContent() && this._isEnabled)) return;
		const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
		const isInTheDom = (findShadowRoot(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
		if (showEvent.defaultPrevented || !isInTheDom) return;
		this._disposePopper();
		const tip = this._getTipElement();
		this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
		const { container } = this._config;
		if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
			container.append(tip);
			EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
		}
		this._popper = this._createPopper(tip);
		tip.classList.add(CLASS_NAME_SHOW$2);
		if ("ontouchstart" in document.documentElement) for (const element of [].concat(...document.body.children)) EventHandler.on(element, "mouseover", noop);
		const complete = () => {
			EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
			if (this._isHovered === false) this._leave();
			this._isHovered = false;
		};
		this._queueCallback(complete, this.tip, this._isAnimated());
	}
	hide() {
		if (!this._isShown()) return;
		if (EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2)).defaultPrevented) return;
		this._getTipElement().classList.remove(CLASS_NAME_SHOW$2);
		if ("ontouchstart" in document.documentElement) for (const element of [].concat(...document.body.children)) EventHandler.off(element, "mouseover", noop);
		this._activeTrigger[TRIGGER_CLICK] = false;
		this._activeTrigger[TRIGGER_FOCUS] = false;
		this._activeTrigger[TRIGGER_HOVER] = false;
		this._isHovered = null;
		const complete = () => {
			if (this._isWithActiveTrigger()) return;
			if (!this._isHovered) this._disposePopper();
			this._element.removeAttribute("aria-describedby");
			EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
		};
		this._queueCallback(complete, this.tip, this._isAnimated());
	}
	update() {
		if (this._popper) this._popper.update();
	}
	_isWithContent() {
		return Boolean(this._getTitle());
	}
	_getTipElement() {
		if (!this.tip) this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
		return this.tip;
	}
	_createTipElement(content) {
		const tip = this._getTemplateFactory(content).toHtml();
		if (!tip) return null;
		tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
		tip.classList.add(`bs-${this.constructor.NAME}-auto`);
		const tipId = getUID(this.constructor.NAME).toString();
		tip.setAttribute("id", tipId);
		if (this._isAnimated()) tip.classList.add(CLASS_NAME_FADE$2);
		return tip;
	}
	setContent(content) {
		this._newContent = content;
		if (this._isShown()) {
			this._disposePopper();
			this.show();
		}
	}
	_getTemplateFactory(content) {
		if (this._templateFactory) this._templateFactory.changeContent(content);
		else this._templateFactory = new TemplateFactory({
			...this._config,
			content,
			extraClass: this._resolvePossibleFunction(this._config.customClass)
		});
		return this._templateFactory;
	}
	_getContentForTemplate() {
		return { [SELECTOR_TOOLTIP_INNER]: this._getTitle() };
	}
	_getTitle() {
		return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
	}
	_initializeOnDelegatedTarget(event) {
		return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
	}
	_isAnimated() {
		return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
	}
	_isShown() {
		return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
	}
	_createPopper(tip) {
		const attachment = AttachmentMap[execute(this._config.placement, [
			this,
			tip,
			this._element
		]).toUpperCase()];
		return createPopper$1(this._element, tip, this._getPopperConfig(attachment));
	}
	_getOffset() {
		const { offset } = this._config;
		if (typeof offset === "string") return offset.split(",").map((value) => Number.parseInt(value, 10));
		if (typeof offset === "function") return (popperData) => offset(popperData, this._element);
		return offset;
	}
	_resolvePossibleFunction(arg) {
		return execute(arg, [this._element, this._element]);
	}
	_getPopperConfig(attachment) {
		const defaultBsPopperConfig = {
			placement: attachment,
			modifiers: [
				{
					name: "flip",
					options: { fallbackPlacements: this._config.fallbackPlacements }
				},
				{
					name: "offset",
					options: { offset: this._getOffset() }
				},
				{
					name: "preventOverflow",
					options: { boundary: this._config.boundary }
				},
				{
					name: "arrow",
					options: { element: `.${this.constructor.NAME}-arrow` }
				},
				{
					name: "preSetPlacement",
					enabled: true,
					phase: "beforeMain",
					fn: (data) => {
						this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
					}
				}
			]
		};
		return {
			...defaultBsPopperConfig,
			...execute(this._config.popperConfig, [void 0, defaultBsPopperConfig])
		};
	}
	_setListeners() {
		const triggers = this._config.trigger.split(" ");
		for (const trigger of triggers) if (trigger === "click") EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
			const context = this._initializeOnDelegatedTarget(event);
			context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);
			context.toggle();
		});
		else if (trigger !== TRIGGER_MANUAL) {
			const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
			const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
			EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
				const context = this._initializeOnDelegatedTarget(event);
				context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
				context._enter();
			});
			EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
				const context = this._initializeOnDelegatedTarget(event);
				context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
				context._leave();
			});
		}
		this._hideModalHandler = () => {
			if (this._element) this.hide();
		};
		EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
	}
	_fixTitle() {
		const title = this._element.getAttribute("title");
		if (!title) return;
		if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) this._element.setAttribute("aria-label", title);
		this._element.setAttribute("data-bs-original-title", title);
		this._element.removeAttribute("title");
	}
	_enter() {
		if (this._isShown() || this._isHovered) {
			this._isHovered = true;
			return;
		}
		this._isHovered = true;
		this._setTimeout(() => {
			if (this._isHovered) this.show();
		}, this._config.delay.show);
	}
	_leave() {
		if (this._isWithActiveTrigger()) return;
		this._isHovered = false;
		this._setTimeout(() => {
			if (!this._isHovered) this.hide();
		}, this._config.delay.hide);
	}
	_setTimeout(handler, timeout) {
		clearTimeout(this._timeout);
		this._timeout = setTimeout(handler, timeout);
	}
	_isWithActiveTrigger() {
		return Object.values(this._activeTrigger).includes(true);
	}
	_getConfig(config) {
		const dataAttributes = Manipulator.getDataAttributes(this._element);
		for (const dataAttribute of Object.keys(dataAttributes)) if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) delete dataAttributes[dataAttribute];
		config = {
			...dataAttributes,
			...typeof config === "object" && config ? config : {}
		};
		config = this._mergeConfigObj(config);
		config = this._configAfterMerge(config);
		this._typeCheckConfig(config);
		return config;
	}
	_configAfterMerge(config) {
		config.container = config.container === false ? document.body : getElement(config.container);
		if (typeof config.delay === "number") config.delay = {
			show: config.delay,
			hide: config.delay
		};
		if (typeof config.title === "number") config.title = config.title.toString();
		if (typeof config.content === "number") config.content = config.content.toString();
		return config;
	}
	_getDelegateConfig() {
		const config = {};
		for (const [key, value] of Object.entries(this._config)) if (this.constructor.Default[key] !== value) config[key] = value;
		config.selector = false;
		config.trigger = "manual";
		return config;
	}
	_disposePopper() {
		if (this._popper) {
			this._popper.destroy();
			this._popper = null;
		}
		if (this.tip) {
			this.tip.remove();
			this.tip = null;
		}
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Tooltip.getOrCreateInstance(this, config);
			if (typeof config !== "string") return;
			if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
			data[config]();
		});
	}
};
/**
* jQuery
*/
defineJQueryPlugin(Tooltip);
/**
* --------------------------------------------------------------------------
* Bootstrap popover.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$3 = "popover";
var SELECTOR_TITLE = ".popover-header";
var SELECTOR_CONTENT = ".popover-body";
var Default$2 = {
	...Tooltip.Default,
	content: "",
	offset: [0, 8],
	placement: "right",
	template: "<div class=\"popover\" role=\"tooltip\"><div class=\"popover-arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>",
	trigger: "click"
};
var DefaultType$2 = {
	...Tooltip.DefaultType,
	content: "(null|string|element|function)"
};
/**
* Class definition
*/
var Popover = class Popover extends Tooltip {
	static get Default() {
		return Default$2;
	}
	static get DefaultType() {
		return DefaultType$2;
	}
	static get NAME() {
		return NAME$3;
	}
	_isWithContent() {
		return this._getTitle() || this._getContent();
	}
	_getContentForTemplate() {
		return {
			[SELECTOR_TITLE]: this._getTitle(),
			[SELECTOR_CONTENT]: this._getContent()
		};
	}
	_getContent() {
		return this._resolvePossibleFunction(this._config.content);
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Popover.getOrCreateInstance(this, config);
			if (typeof config !== "string") return;
			if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
			data[config]();
		});
	}
};
/**
* jQuery
*/
defineJQueryPlugin(Popover);
/**
* --------------------------------------------------------------------------
* Bootstrap scrollspy.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$2 = "scrollspy";
var EVENT_KEY$2 = `.bs.scrollspy`;
var DATA_API_KEY = ".data-api";
var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
var EVENT_CLICK = `click${EVENT_KEY$2}`;
var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
var CLASS_NAME_ACTIVE$1 = "active";
var SELECTOR_DATA_SPY = "[data-bs-spy=\"scroll\"]";
var SELECTOR_TARGET_LINKS = "[href]";
var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
var SELECTOR_NAV_LINKS = ".nav-link";
var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, .nav-item > ${SELECTOR_NAV_LINKS}, .list-group-item`;
var SELECTOR_DROPDOWN = ".dropdown";
var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
var Default$1 = {
	offset: null,
	rootMargin: "0px 0px -25%",
	smoothScroll: false,
	target: null,
	threshold: [
		.1,
		.5,
		1
	]
};
var DefaultType$1 = {
	offset: "(number|null)",
	rootMargin: "string",
	smoothScroll: "boolean",
	target: "element",
	threshold: "array"
};
/**
* Class definition
*/
var ScrollSpy = class ScrollSpy extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._targetLinks = /* @__PURE__ */ new Map();
		this._observableSections = /* @__PURE__ */ new Map();
		this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
		this._activeTarget = null;
		this._observer = null;
		this._previousScrollData = {
			visibleEntryTop: 0,
			parentScrollTop: 0
		};
		this.refresh();
	}
	static get Default() {
		return Default$1;
	}
	static get DefaultType() {
		return DefaultType$1;
	}
	static get NAME() {
		return NAME$2;
	}
	refresh() {
		this._initializeTargetsAndObservables();
		this._maybeEnableSmoothScroll();
		if (this._observer) this._observer.disconnect();
		else this._observer = this._getNewObserver();
		for (const section of this._observableSections.values()) this._observer.observe(section);
	}
	dispose() {
		this._observer.disconnect();
		super.dispose();
	}
	_configAfterMerge(config) {
		config.target = getElement(config.target) || document.body;
		config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
		if (typeof config.threshold === "string") config.threshold = config.threshold.split(",").map((value) => Number.parseFloat(value));
		return config;
	}
	_maybeEnableSmoothScroll() {
		if (!this._config.smoothScroll) return;
		EventHandler.off(this._config.target, EVENT_CLICK);
		EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
			const observableSection = this._observableSections.get(event.target.hash);
			if (observableSection) {
				event.preventDefault();
				const root = this._rootElement || window;
				const height = observableSection.offsetTop - this._element.offsetTop;
				if (root.scrollTo) {
					root.scrollTo({
						top: height,
						behavior: "smooth"
					});
					return;
				}
				root.scrollTop = height;
			}
		});
	}
	_getNewObserver() {
		const options = {
			root: this._rootElement,
			threshold: this._config.threshold,
			rootMargin: this._config.rootMargin
		};
		return new IntersectionObserver((entries) => this._observerCallback(entries), options);
	}
	_observerCallback(entries) {
		const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
		const activate = (entry) => {
			this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
			this._process(targetElement(entry));
		};
		const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
		const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
		this._previousScrollData.parentScrollTop = parentScrollTop;
		for (const entry of entries) {
			if (!entry.isIntersecting) {
				this._activeTarget = null;
				this._clearActiveClass(targetElement(entry));
				continue;
			}
			const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
			if (userScrollsDown && entryIsLowerThanPrevious) {
				activate(entry);
				if (!parentScrollTop) return;
				continue;
			}
			if (!userScrollsDown && !entryIsLowerThanPrevious) activate(entry);
		}
	}
	_initializeTargetsAndObservables() {
		this._targetLinks = /* @__PURE__ */ new Map();
		this._observableSections = /* @__PURE__ */ new Map();
		const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
		for (const anchor of targetLinks) {
			if (!anchor.hash || isDisabled(anchor)) continue;
			const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
			if (isVisible(observableSection)) {
				this._targetLinks.set(decodeURI(anchor.hash), anchor);
				this._observableSections.set(anchor.hash, observableSection);
			}
		}
	}
	_process(target) {
		if (this._activeTarget === target) return;
		this._clearActiveClass(this._config.target);
		this._activeTarget = target;
		target.classList.add(CLASS_NAME_ACTIVE$1);
		this._activateParents(target);
		EventHandler.trigger(this._element, EVENT_ACTIVATE, { relatedTarget: target });
	}
	_activateParents(target) {
		if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
			SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
			return;
		}
		for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) item.classList.add(CLASS_NAME_ACTIVE$1);
	}
	_clearActiveClass(parent) {
		parent.classList.remove(CLASS_NAME_ACTIVE$1);
		const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
		for (const node of activeNodes) node.classList.remove(CLASS_NAME_ACTIVE$1);
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = ScrollSpy.getOrCreateInstance(this, config);
			if (typeof config !== "string") return;
			if (data[config] === void 0 || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
			data[config]();
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
	for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) ScrollSpy.getOrCreateInstance(spy);
});
/**
* jQuery
*/
defineJQueryPlugin(ScrollSpy);
/**
* --------------------------------------------------------------------------
* Bootstrap tab.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME$1 = "tab";
var EVENT_KEY$1 = `.bs.tab`;
var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
var ARROW_LEFT_KEY = "ArrowLeft";
var ARROW_RIGHT_KEY = "ArrowRight";
var ARROW_UP_KEY = "ArrowUp";
var ARROW_DOWN_KEY = "ArrowDown";
var HOME_KEY = "Home";
var END_KEY = "End";
var CLASS_NAME_ACTIVE = "active";
var CLASS_NAME_FADE$1 = "fade";
var CLASS_NAME_SHOW$1 = "show";
var CLASS_DROPDOWN = "dropdown";
var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
var NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
var SELECTOR_TAB_PANEL = ".list-group, .nav, [role=\"tablist\"]";
var SELECTOR_OUTER = ".nav-item, .list-group-item";
var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
var SELECTOR_DATA_TOGGLE = "[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]";
var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
/**
* Class definition
*/
var Tab = class Tab extends BaseComponent {
	constructor(element) {
		super(element);
		this._parent = this._element.closest(SELECTOR_TAB_PANEL);
		if (!this._parent) return;
		this._setInitialAttributes(this._parent, this._getChildren());
		EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
	}
	static get NAME() {
		return NAME$1;
	}
	show() {
		const innerElem = this._element;
		if (this._elemIsActive(innerElem)) return;
		const active = this._getActiveElem();
		const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, { relatedTarget: innerElem }) : null;
		if (EventHandler.trigger(innerElem, EVENT_SHOW$1, { relatedTarget: active }).defaultPrevented || hideEvent && hideEvent.defaultPrevented) return;
		this._deactivate(active, innerElem);
		this._activate(innerElem, active);
	}
	_activate(element, relatedElem) {
		if (!element) return;
		element.classList.add(CLASS_NAME_ACTIVE);
		this._activate(SelectorEngine.getElementFromSelector(element));
		const complete = () => {
			if (element.getAttribute("role") !== "tab") {
				element.classList.add(CLASS_NAME_SHOW$1);
				return;
			}
			element.removeAttribute("tabindex");
			element.setAttribute("aria-selected", true);
			this._toggleDropDown(element, true);
			EventHandler.trigger(element, EVENT_SHOWN$1, { relatedTarget: relatedElem });
		};
		this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
	}
	_deactivate(element, relatedElem) {
		if (!element) return;
		element.classList.remove(CLASS_NAME_ACTIVE);
		element.blur();
		this._deactivate(SelectorEngine.getElementFromSelector(element));
		const complete = () => {
			if (element.getAttribute("role") !== "tab") {
				element.classList.remove(CLASS_NAME_SHOW$1);
				return;
			}
			element.setAttribute("aria-selected", false);
			element.setAttribute("tabindex", "-1");
			this._toggleDropDown(element, false);
			EventHandler.trigger(element, EVENT_HIDDEN$1, { relatedTarget: relatedElem });
		};
		this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
	}
	_keydown(event) {
		if (![
			ARROW_LEFT_KEY,
			ARROW_RIGHT_KEY,
			ARROW_UP_KEY,
			ARROW_DOWN_KEY,
			HOME_KEY,
			END_KEY
		].includes(event.key)) return;
		event.stopPropagation();
		event.preventDefault();
		const children = this._getChildren().filter((element) => !isDisabled(element));
		let nextActiveElement;
		if ([HOME_KEY, END_KEY].includes(event.key)) nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
		else {
			const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
			nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
		}
		if (nextActiveElement) {
			nextActiveElement.focus({ preventScroll: true });
			Tab.getOrCreateInstance(nextActiveElement).show();
		}
	}
	_getChildren() {
		return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
	}
	_getActiveElem() {
		return this._getChildren().find((child) => this._elemIsActive(child)) || null;
	}
	_setInitialAttributes(parent, children) {
		this._setAttributeIfNotExists(parent, "role", "tablist");
		for (const child of children) this._setInitialAttributesOnChild(child);
	}
	_setInitialAttributesOnChild(child) {
		child = this._getInnerElement(child);
		const isActive = this._elemIsActive(child);
		const outerElem = this._getOuterElement(child);
		child.setAttribute("aria-selected", isActive);
		if (outerElem !== child) this._setAttributeIfNotExists(outerElem, "role", "presentation");
		if (!isActive) child.setAttribute("tabindex", "-1");
		this._setAttributeIfNotExists(child, "role", "tab");
		this._setInitialAttributesOnTargetPanel(child);
	}
	_setInitialAttributesOnTargetPanel(child) {
		const target = SelectorEngine.getElementFromSelector(child);
		if (!target) return;
		this._setAttributeIfNotExists(target, "role", "tabpanel");
		if (child.id) this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
	}
	_toggleDropDown(element, open) {
		const outerElem = this._getOuterElement(element);
		if (!outerElem.classList.contains(CLASS_DROPDOWN)) return;
		const toggle = (selector, className) => {
			const element$1 = SelectorEngine.findOne(selector, outerElem);
			if (element$1) element$1.classList.toggle(className, open);
		};
		toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
		toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
		outerElem.setAttribute("aria-expanded", open);
	}
	_setAttributeIfNotExists(element, attribute, value) {
		if (!element.hasAttribute(attribute)) element.setAttribute(attribute, value);
	}
	_elemIsActive(elem) {
		return elem.classList.contains(CLASS_NAME_ACTIVE);
	}
	_getInnerElement(elem) {
		return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
	}
	_getOuterElement(elem) {
		return elem.closest(SELECTOR_OUTER) || elem;
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Tab.getOrCreateInstance(this);
			if (typeof config !== "string") return;
			if (data[config] === void 0 || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
			data[config]();
		});
	}
};
/**
* Data API implementation
*/
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
	if (["A", "AREA"].includes(this.tagName)) event.preventDefault();
	if (isDisabled(this)) return;
	Tab.getOrCreateInstance(this).show();
});
/**
* Initialize on focus
*/
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
	for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) Tab.getOrCreateInstance(element);
});
/**
* jQuery
*/
defineJQueryPlugin(Tab);
/**
* --------------------------------------------------------------------------
* Bootstrap toast.js
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
* --------------------------------------------------------------------------
*/
/**
* Constants
*/
var NAME = "toast";
var EVENT_KEY = `.bs.toast`;
var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
var EVENT_HIDE = `hide${EVENT_KEY}`;
var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
var EVENT_SHOW = `show${EVENT_KEY}`;
var EVENT_SHOWN = `shown${EVENT_KEY}`;
var CLASS_NAME_FADE = "fade";
var CLASS_NAME_HIDE = "hide";
var CLASS_NAME_SHOW = "show";
var CLASS_NAME_SHOWING = "showing";
var DefaultType = {
	animation: "boolean",
	autohide: "boolean",
	delay: "number"
};
var Default = {
	animation: true,
	autohide: true,
	delay: 5e3
};
/**
* Class definition
*/
var Toast = class Toast extends BaseComponent {
	constructor(element, config) {
		super(element, config);
		this._timeout = null;
		this._hasMouseInteraction = false;
		this._hasKeyboardInteraction = false;
		this._setListeners();
	}
	static get Default() {
		return Default;
	}
	static get DefaultType() {
		return DefaultType;
	}
	static get NAME() {
		return NAME;
	}
	show() {
		if (EventHandler.trigger(this._element, EVENT_SHOW).defaultPrevented) return;
		this._clearTimeout();
		if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
		const complete = () => {
			this._element.classList.remove(CLASS_NAME_SHOWING);
			EventHandler.trigger(this._element, EVENT_SHOWN);
			this._maybeScheduleHide();
		};
		this._element.classList.remove(CLASS_NAME_HIDE);
		reflow(this._element);
		this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
		this._queueCallback(complete, this._element, this._config.animation);
	}
	hide() {
		if (!this.isShown()) return;
		if (EventHandler.trigger(this._element, EVENT_HIDE).defaultPrevented) return;
		const complete = () => {
			this._element.classList.add(CLASS_NAME_HIDE);
			this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
			EventHandler.trigger(this._element, EVENT_HIDDEN);
		};
		this._element.classList.add(CLASS_NAME_SHOWING);
		this._queueCallback(complete, this._element, this._config.animation);
	}
	dispose() {
		this._clearTimeout();
		if (this.isShown()) this._element.classList.remove(CLASS_NAME_SHOW);
		super.dispose();
	}
	isShown() {
		return this._element.classList.contains(CLASS_NAME_SHOW);
	}
	_maybeScheduleHide() {
		if (!this._config.autohide) return;
		if (this._hasMouseInteraction || this._hasKeyboardInteraction) return;
		this._timeout = setTimeout(() => {
			this.hide();
		}, this._config.delay);
	}
	_onInteraction(event, isInteracting) {
		switch (event.type) {
			case "mouseover":
			case "mouseout":
				this._hasMouseInteraction = isInteracting;
				break;
			case "focusin":
			case "focusout":
				this._hasKeyboardInteraction = isInteracting;
				break;
		}
		if (isInteracting) {
			this._clearTimeout();
			return;
		}
		const nextElement = event.relatedTarget;
		if (this._element === nextElement || this._element.contains(nextElement)) return;
		this._maybeScheduleHide();
	}
	_setListeners() {
		EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
		EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
		EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
		EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
	}
	_clearTimeout() {
		clearTimeout(this._timeout);
		this._timeout = null;
	}
	static jQueryInterface(config) {
		return this.each(function() {
			const data = Toast.getOrCreateInstance(this, config);
			if (typeof config === "string") {
				if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
				data[config](this);
			}
		});
	}
};
/**
* Data API implementation
*/
enableDismissTrigger(Toast);
/**
* jQuery
*/
defineJQueryPlugin(Toast);

//#endregion
export { Alert, Button, Carousel, Collapse, Dropdown, Modal, Offcanvas, Popover, ScrollSpy, Tab, Toast, Tooltip };
//# sourceMappingURL=bootstrap.js.map