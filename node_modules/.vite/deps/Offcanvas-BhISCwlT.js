import { r as __toESM } from "./chunk-DUEDWNxO.js";
import { t as require_react } from "./react-x9Y-BYRK.js";
import { t as require_jsx_runtime } from "./jsx-runtime-CQf3Gven.js";
import { c as require_classnames, o as useBootstrapPrefix } from "./ThemeProvider-DKTT7lwV.js";
import { I as ENTERED, L as ENTERING, O as transitionEndListener, P as getChildRef, S as useEventCallback, _ as Fade_default, i as getSharedManager, n as ModalContext_default, o as Modal_default, r as BootstrapModalManager_default, t as AbstractModalHeader_default, w as TransitionWrapper_default, x as divWithClassName_default, z as EXITING } from "./AbstractModalHeader-Bsf6UFHL.js";

//#region node_modules/@restart/hooks/esm/useIsomorphicEffect.js
var import_react = require_react();
var isReactNative = typeof global !== "undefined" && global.navigator && global.navigator.product === "ReactNative";
var isDOM = typeof document !== "undefined";
/**
* Is `useLayoutEffect` in a DOM or React Native environment, otherwise resolves to useEffect
* Only useful to avoid the console warning.
*
* PREFER `useEffect` UNLESS YOU KNOW WHAT YOU ARE DOING.
*
* @category effects
*/
var useIsomorphicEffect_default = isDOM || isReactNative ? import_react.useLayoutEffect : import_react.useEffect;

//#endregion
//#region node_modules/@restart/hooks/esm/useMediaQuery.js
var matchersByWindow = /* @__PURE__ */ new WeakMap();
var getMatcher = (query, targetWindow) => {
	if (!query || !targetWindow) return void 0;
	const matchers = matchersByWindow.get(targetWindow) || /* @__PURE__ */ new Map();
	matchersByWindow.set(targetWindow, matchers);
	let mql = matchers.get(query);
	if (!mql) {
		mql = targetWindow.matchMedia(query);
		mql.refCount = 0;
		matchers.set(mql.media, mql);
	}
	return mql;
};
/**
* Match a media query and get updates as the match changes. The media string is
* passed directly to `window.matchMedia` and run as a Layout Effect, so initial
* matches are returned before the browser has a chance to paint.
*
* ```tsx
* function Page() {
*   const isWide = useMediaQuery('min-width: 1000px')
*
*   return isWide ? "very wide" : 'not so wide'
* }
* ```
*
* Media query lists are also reused globally, hook calls for the same query
* will only create a matcher once under the hood.
*
* @param query A media query
* @param targetWindow The window to match against, uses the globally available one as a default.
*/
function useMediaQuery(query, targetWindow = typeof window === "undefined" ? void 0 : window) {
	const mql = getMatcher(query, targetWindow);
	const [matches, setMatches] = (0, import_react.useState)(() => mql ? mql.matches : false);
	useIsomorphicEffect_default(() => {
		let mql$1 = getMatcher(query, targetWindow);
		if (!mql$1) return setMatches(false);
		let matchers = matchersByWindow.get(targetWindow);
		const handleChange = () => {
			setMatches(mql$1.matches);
		};
		mql$1.refCount++;
		mql$1.addListener(handleChange);
		handleChange();
		return () => {
			mql$1.removeListener(handleChange);
			mql$1.refCount--;
			if (mql$1.refCount <= 0) matchers?.delete(mql$1.media);
			mql$1 = void 0;
		};
	}, [query]);
	return matches;
}

//#endregion
//#region node_modules/@restart/hooks/esm/useBreakpoint.js
/**
* Create a responsive hook we a set of breakpoint names and widths.
* You can use any valid css units as well as a numbers (for pixels).
*
* **NOTE:** The object key order is important! it's assumed to be in order from smallest to largest
*
* ```ts
* const useBreakpoint = createBreakpointHook({
*  xs: 0,
*  sm: 576,
*  md: 768,
*  lg: 992,
*  xl: 1200,
* })
* ```
*
* **Watch out!** using string values will sometimes construct media queries using css `calc()` which
* is NOT supported in media queries by all browsers at the moment. use numbers for
* the widest range of browser support.
*
* @param breakpointValues A object hash of names to breakpoint dimensions
*/
function createBreakpointHook(breakpointValues) {
	const names = Object.keys(breakpointValues);
	function and(query, next) {
		if (query === next) return next;
		return query ? `${query} and ${next}` : next;
	}
	function getNext(breakpoint) {
		return names[Math.min(names.indexOf(breakpoint) + 1, names.length - 1)];
	}
	function getMaxQuery(breakpoint) {
		let value = breakpointValues[getNext(breakpoint)];
		if (typeof value === "number") value = `${value - .2}px`;
		else value = `calc(${value} - 0.2px)`;
		return `(max-width: ${value})`;
	}
	function getMinQuery(breakpoint) {
		let value = breakpointValues[breakpoint];
		if (typeof value === "number") value = `${value}px`;
		return `(min-width: ${value})`;
	}
	/**
	* Match a set of breakpoints
	*
	* ```tsx
	* const MidSizeOnly = () => {
	*   const isMid = useBreakpoint({ lg: 'down', sm: 'up' });
	*
	*   if (isMid) return <div>On a Reasonable sized Screen!</div>
	*   return null;
	* }
	* ```
	* @param breakpointMap An object map of breakpoints and directions, queries are constructed using "and" to join
	* breakpoints together
	* @param window Optionally specify the target window to match against (useful when rendering into iframes)
	*/
	/**
	* Match a single breakpoint exactly, up, or down.
	*
	* ```tsx
	* const PhoneOnly = () => {
	*   const isSmall = useBreakpoint('sm', 'down');
	*
	*   if (isSmall) return <div>On a Small Screen!</div>
	*   return null;
	* }
	* ```
	*
	* @param breakpoint The breakpoint key
	* @param direction A direction 'up' for a max, 'down' for min, true to match only the breakpoint
	* @param window Optionally specify the target window to match against (useful when rendering into iframes)
	*/
	function useBreakpoint$1(breakpointOrMap, direction, window$1) {
		let breakpointMap;
		if (typeof breakpointOrMap === "object") {
			breakpointMap = breakpointOrMap;
			window$1 = direction;
			direction = true;
		} else {
			direction = direction || true;
			breakpointMap = { [breakpointOrMap]: direction };
		}
		return useMediaQuery((0, import_react.useMemo)(() => Object.entries(breakpointMap).reduce((query, [key, direction$1]) => {
			if (direction$1 === "up" || direction$1 === true) query = and(query, getMinQuery(key));
			if (direction$1 === "down" || direction$1 === true) query = and(query, getMaxQuery(key));
			return query;
		}, ""), [JSON.stringify(breakpointMap)]), window$1);
	}
	return useBreakpoint$1;
}
var useBreakpoint = createBreakpointHook({
	xs: 0,
	sm: 576,
	md: 768,
	lg: 992,
	xl: 1200,
	xxl: 1400
});
var useBreakpoint_default = useBreakpoint;

//#endregion
//#region node_modules/react-bootstrap/esm/OffcanvasBody.js
var import_classnames$4 = /* @__PURE__ */ __toESM(require_classnames());
var import_jsx_runtime = require_jsx_runtime();
var OffcanvasBody = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = "div", ...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "offcanvas-body");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$4.default)(className, bsPrefix),
		...props
	});
});
OffcanvasBody.displayName = "OffcanvasBody";
var OffcanvasBody_default = OffcanvasBody;

//#endregion
//#region node_modules/react-bootstrap/esm/OffcanvasToggling.js
var import_classnames$3 = /* @__PURE__ */ __toESM(require_classnames());
var transitionStyles = {
	[ENTERING]: "show",
	[ENTERED]: "show"
};
var OffcanvasToggling = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, children, in: inProp = false, mountOnEnter = false, unmountOnExit = false, appear = false, ...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "offcanvas");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TransitionWrapper_default, {
		ref,
		addEndListener: transitionEndListener,
		in: inProp,
		mountOnEnter,
		unmountOnExit,
		appear,
		...props,
		childRef: getChildRef(children),
		children: (status, innerProps) => /* @__PURE__ */ import_react.cloneElement(children, {
			...innerProps,
			className: (0, import_classnames$3.default)(className, children.props.className, (status === ENTERING || status === EXITING) && `${bsPrefix}-toggling`, transitionStyles[status])
		})
	});
});
OffcanvasToggling.displayName = "OffcanvasToggling";
var OffcanvasToggling_default = OffcanvasToggling;

//#endregion
//#region node_modules/react-bootstrap/esm/OffcanvasHeader.js
var import_classnames$2 = /* @__PURE__ */ __toESM(require_classnames());
var OffcanvasHeader = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, closeLabel = "Close", closeButton = false, ...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "offcanvas-header");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AbstractModalHeader_default, {
		ref,
		...props,
		className: (0, import_classnames$2.default)(className, bsPrefix),
		closeLabel,
		closeButton
	});
});
OffcanvasHeader.displayName = "OffcanvasHeader";
var OffcanvasHeader_default = OffcanvasHeader;

//#endregion
//#region node_modules/react-bootstrap/esm/OffcanvasTitle.js
var import_classnames$1 = /* @__PURE__ */ __toESM(require_classnames());
var DivStyledAsH5 = divWithClassName_default("h5");
var OffcanvasTitle = /* @__PURE__ */ import_react.forwardRef(({ className, bsPrefix, as: Component = DivStyledAsH5, ...props }, ref) => {
	bsPrefix = useBootstrapPrefix(bsPrefix, "offcanvas-title");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
		ref,
		className: (0, import_classnames$1.default)(className, bsPrefix),
		...props
	});
});
OffcanvasTitle.displayName = "OffcanvasTitle";
var OffcanvasTitle_default = OffcanvasTitle;

//#endregion
//#region node_modules/react-bootstrap/esm/Offcanvas.js
var import_classnames = /* @__PURE__ */ __toESM(require_classnames());
function DialogTransition(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OffcanvasToggling_default, { ...props });
}
function BackdropTransition(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Fade_default, { ...props });
}
var Offcanvas = /* @__PURE__ */ import_react.forwardRef(({ bsPrefix, className, children, "aria-labelledby": ariaLabelledby, placement = "start", responsive, show = false, backdrop = true, keyboard = true, scroll = false, onEscapeKeyDown, onShow, onHide, container, autoFocus = true, enforceFocus = true, restoreFocus = true, restoreFocusOptions, onEntered, onExit, onExiting, onEnter, onEntering, onExited, backdropClassName, manager: propsManager, renderStaticNode = false, ...props }, ref) => {
	const modalManager = (0, import_react.useRef)();
	bsPrefix = useBootstrapPrefix(bsPrefix, "offcanvas");
	const [showOffcanvas, setShowOffcanvas] = (0, import_react.useState)(false);
	const handleHide = useEventCallback(onHide);
	const hideResponsiveOffcanvas = useBreakpoint_default(responsive || "xs", "up");
	(0, import_react.useEffect)(() => {
		setShowOffcanvas(responsive ? show && !hideResponsiveOffcanvas : show);
	}, [
		show,
		responsive,
		hideResponsiveOffcanvas
	]);
	const modalContext = (0, import_react.useMemo)(() => ({ onHide: handleHide }), [handleHide]);
	function getModalManager() {
		if (propsManager) return propsManager;
		if (scroll) {
			if (!modalManager.current) modalManager.current = new BootstrapModalManager_default({ handleContainerOverflow: false });
			return modalManager.current;
		}
		return getSharedManager();
	}
	const handleEnter = (node, ...args) => {
		if (node) node.style.visibility = "visible";
		onEnter?.(node, ...args);
	};
	const handleExited = (node, ...args) => {
		if (node) node.style.visibility = "";
		onExited?.(...args);
	};
	const renderBackdrop = (0, import_react.useCallback)((backdropProps) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...backdropProps,
		className: (0, import_classnames.default)(`${bsPrefix}-backdrop`, backdropClassName)
	}), [backdropClassName, bsPrefix]);
	const renderDialog = (dialogProps) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...dialogProps,
		...props,
		className: (0, import_classnames.default)(className, responsive ? `${bsPrefix}-${responsive}` : bsPrefix, `${bsPrefix}-${placement}`),
		"aria-labelledby": ariaLabelledby,
		children
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [!showOffcanvas && (responsive || renderStaticNode) && renderDialog({}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ModalContext_default.Provider, {
		value: modalContext,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Modal_default, {
			show: showOffcanvas,
			ref,
			backdrop,
			container,
			keyboard,
			autoFocus,
			enforceFocus: enforceFocus && !scroll,
			restoreFocus,
			restoreFocusOptions,
			onEscapeKeyDown,
			onShow,
			onHide: handleHide,
			onEnter: handleEnter,
			onEntering,
			onEntered,
			onExit,
			onExiting,
			onExited: handleExited,
			manager: getModalManager(),
			transition: DialogTransition,
			backdropTransition: BackdropTransition,
			renderBackdrop,
			renderDialog
		})
	})] });
});
Offcanvas.displayName = "Offcanvas";
var Offcanvas_default = Object.assign(Offcanvas, {
	Body: OffcanvasBody_default,
	Header: OffcanvasHeader_default,
	Title: OffcanvasTitle_default
});

//#endregion
export { OffcanvasBody_default as a, OffcanvasToggling_default as i, OffcanvasTitle_default as n, useIsomorphicEffect_default as o, OffcanvasHeader_default as r, Offcanvas_default as t };
//# sourceMappingURL=Offcanvas-BhISCwlT.js.map