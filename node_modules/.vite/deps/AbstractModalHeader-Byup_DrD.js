import { r as __toESM } from "./chunk-DUEDWNxO.js";
import { t as require_react } from "./react-x9Y-BYRK.js";
import { t as require_react_dom } from "./react-dom-BpfFNzFJ.js";
import { t as require_jsx_runtime } from "./jsx-runtime-CQf3Gven.js";
import { c as require_classnames } from "./ThemeProvider-bmGA7CRm.js";
import { C as ownerDocument, S as css_default, d as listen_default, g as isEscKey, h as getChildRef, i as useEventCallback$1, m as canUseDOM_default, n as useMergedRefs_default, t as NoopTransition_default, x as require_prop_types } from "./NoopTransition-CtkKZUuN.js";
import { a as usePrevious, i as useIsomorphicEffect_default, o as useMounted, r as qsa, t as dataAttr } from "./DataKey-BWA-BAff.js";

//#region node_modules/@restart/hooks/esm/useCommittedRef.js
var import_react = require_react();
/**
* Creates a `Ref` whose value is updated in an effect, ensuring the most recent
* value is the one rendered with. Generally only required for Concurrent mode usage
* where previous work in `render()` may be discarded before being used.
*
* This is safe to access in an event handler.
*
* @param value The `Ref` value
*/
function useCommittedRef(value) {
	const ref = (0, import_react.useRef)(value);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	}, [value]);
	return ref;
}
var useCommittedRef_default = useCommittedRef;

//#endregion
//#region node_modules/@restart/hooks/esm/useEventCallback.js
function useEventCallback(fn) {
	const ref = useCommittedRef_default(fn);
	return (0, import_react.useCallback)(function(...args) {
		return ref.current && ref.current(...args);
	}, [ref]);
}

//#endregion
//#region node_modules/react-bootstrap/esm/divWithClassName.js
var import_classnames$1 = /* @__PURE__ */ __toESM(require_classnames());
var import_jsx_runtime = require_jsx_runtime();
var divWithClassName_default = ((className) => /* @__PURE__ */ import_react.forwardRef((p, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
	...p,
	ref,
	className: (0, import_classnames$1.default)(p.className, className)
})));

//#endregion
//#region node_modules/react-bootstrap/esm/CloseButton.js
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types());
var import_classnames = /* @__PURE__ */ __toESM(require_classnames());
var propTypes = {
	"aria-label": import_prop_types.default.string,
	onClick: import_prop_types.default.func,
	variant: import_prop_types.default.oneOf(["white"])
};
var CloseButton = /* @__PURE__ */ import_react.forwardRef(({ className, variant, "aria-label": ariaLabel = "Close", ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
	ref,
	type: "button",
	className: (0, import_classnames.default)("btn-close", variant && `btn-close-${variant}`, className),
	"aria-label": ariaLabel,
	...props
}));
CloseButton.displayName = "CloseButton";
CloseButton.propTypes = propTypes;
var CloseButton_default = CloseButton;

//#endregion
//#region node_modules/dom-helpers/esm/contains.js
/**
* Checks if an element contains another given element.
* 
* @param context the context element
* @param node the element to check
*/
function contains(context, node) {
	if (context.contains) return context.contains(node);
	if (context.compareDocumentPosition) return context === node || !!(context.compareDocumentPosition(node) & 16);
}

//#endregion
//#region node_modules/@restart/ui/esm/useWindow.js
var Context = /* @__PURE__ */ (0, import_react.createContext)(canUseDOM_default ? window : void 0);
const WindowProvider = Context.Provider;
/**
* The document "window" placed in React context. Helpful for determining
* SSR context, or when rendering into an iframe.
*
* @returns the current window
*/
function useWindow() {
	return (0, import_react.useContext)(Context);
}

//#endregion
//#region node_modules/dom-helpers/esm/activeElement.js
/**
* Returns the actively focused element safely.
*
* @param doc the document to check
*/
function activeElement(doc) {
	if (doc === void 0) doc = ownerDocument();
	try {
		var active = doc.activeElement;
		if (!active || !active.nodeName) return null;
		return active;
	} catch (e) {
		return doc.body;
	}
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useUpdatedRef.js
/**
* Returns a ref that is immediately updated with the new value
*
* @param value The Ref value
* @category refs
*/
function useUpdatedRef(value) {
	const valueRef = (0, import_react.useRef)(value);
	valueRef.current = value;
	return valueRef;
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useWillUnmount.js
/**
* Attach a callback that fires when a component unmounts
*
* @param fn Handler to run when the component unmounts
* @deprecated Use `useMounted` and normal effects, this is not StrictMode safe
* @category effects
*/
function useWillUnmount(fn) {
	const onUnmount = useUpdatedRef(fn);
	(0, import_react.useEffect)(() => () => onUnmount.current(), []);
}

//#endregion
//#region node_modules/@restart/ui/esm/getScrollbarWidth.js
/**
* Get the width of the vertical window scrollbar if it's visible
*/
function getBodyScrollbarWidth(ownerDocument$1 = document) {
	const window$1 = ownerDocument$1.defaultView;
	return Math.abs(window$1.innerWidth - ownerDocument$1.documentElement.clientWidth);
}

//#endregion
//#region node_modules/@restart/ui/esm/ModalManager.js
const OPEN_DATA_ATTRIBUTE = dataAttr("modal-open");
/**
* Manages a stack of Modals as well as ensuring
* body scrolling is is disabled and padding accounted for
*/
var ModalManager = class {
	constructor({ ownerDocument: ownerDocument$1, handleContainerOverflow = true, isRTL = false } = {}) {
		this.handleContainerOverflow = handleContainerOverflow;
		this.isRTL = isRTL;
		this.modals = [];
		this.ownerDocument = ownerDocument$1;
	}
	getScrollbarWidth() {
		return getBodyScrollbarWidth(this.ownerDocument);
	}
	getElement() {
		return (this.ownerDocument || document).body;
	}
	setModalAttributes(_modal) {}
	removeModalAttributes(_modal) {}
	setContainerStyle(containerState) {
		const style = { overflow: "hidden" };
		const paddingProp = this.isRTL ? "paddingLeft" : "paddingRight";
		const container = this.getElement();
		containerState.style = {
			overflow: container.style.overflow,
			[paddingProp]: container.style[paddingProp]
		};
		if (containerState.scrollBarWidth) style[paddingProp] = `${parseInt(css_default(container, paddingProp) || "0", 10) + containerState.scrollBarWidth}px`;
		container.setAttribute(OPEN_DATA_ATTRIBUTE, "");
		css_default(container, style);
	}
	reset() {
		[...this.modals].forEach((m) => this.remove(m));
	}
	removeContainerStyle(containerState) {
		const container = this.getElement();
		container.removeAttribute(OPEN_DATA_ATTRIBUTE);
		Object.assign(container.style, containerState.style);
	}
	add(modal) {
		let modalIdx = this.modals.indexOf(modal);
		if (modalIdx !== -1) return modalIdx;
		modalIdx = this.modals.length;
		this.modals.push(modal);
		this.setModalAttributes(modal);
		if (modalIdx !== 0) return modalIdx;
		this.state = {
			scrollBarWidth: this.getScrollbarWidth(),
			style: {}
		};
		if (this.handleContainerOverflow) this.setContainerStyle(this.state);
		return modalIdx;
	}
	remove(modal) {
		const modalIdx = this.modals.indexOf(modal);
		if (modalIdx === -1) return;
		this.modals.splice(modalIdx, 1);
		if (!this.modals.length && this.handleContainerOverflow) this.removeContainerStyle(this.state);
		this.removeModalAttributes(modal);
	}
	isTopModal(modal) {
		return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
	}
};
var ModalManager_default = ModalManager;

//#endregion
//#region node_modules/@restart/ui/esm/useWaitForDOMRef.js
const resolveContainerRef = (ref, document$1) => {
	if (!canUseDOM_default) return null;
	if (ref == null) return (document$1 || ownerDocument()).body;
	if (typeof ref === "function") ref = ref();
	if (ref && "current" in ref) ref = ref.current;
	if (ref && ("nodeType" in ref || ref.getBoundingClientRect)) return ref;
	return null;
};
function useWaitForDOMRef(ref, onResolved) {
	const window$1 = useWindow();
	const [resolvedRef, setRef] = (0, import_react.useState)(() => resolveContainerRef(ref, window$1 == null ? void 0 : window$1.document));
	if (!resolvedRef) {
		const earlyRef = resolveContainerRef(ref);
		if (earlyRef) setRef(earlyRef);
	}
	(0, import_react.useEffect)(() => {
		if (onResolved && resolvedRef) onResolved(resolvedRef);
	}, [onResolved, resolvedRef]);
	(0, import_react.useEffect)(() => {
		const nextRef = resolveContainerRef(ref);
		if (nextRef !== resolvedRef) setRef(nextRef);
	}, [ref, resolvedRef]);
	return resolvedRef;
}

//#endregion
//#region node_modules/@restart/ui/esm/useRTGTransitionProps.js
var _excluded$2 = [
	"onEnter",
	"onEntering",
	"onEntered",
	"onExit",
	"onExiting",
	"onExited",
	"addEndListener",
	"children"
];
function _objectWithoutPropertiesLoose$2(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
/**
* Normalizes RTG transition callbacks with nodeRef to better support
* strict mode.
*
* @param props Transition props.
* @returns Normalized transition props.
*/
function useRTGTransitionProps(_ref) {
	let { onEnter, onEntering, onEntered, onExit, onExiting, onExited, addEndListener, children } = _ref, props = _objectWithoutPropertiesLoose$2(_ref, _excluded$2);
	const nodeRef = (0, import_react.useRef)(null);
	const mergedRef = useMergedRefs_default(nodeRef, getChildRef(children));
	const normalize = (callback) => (param) => {
		if (callback && nodeRef.current) callback(nodeRef.current, param);
	};
	const handleEnter = (0, import_react.useCallback)(normalize(onEnter), [onEnter]);
	const handleEntering = (0, import_react.useCallback)(normalize(onEntering), [onEntering]);
	const handleEntered = (0, import_react.useCallback)(normalize(onEntered), [onEntered]);
	const handleExit = (0, import_react.useCallback)(normalize(onExit), [onExit]);
	const handleExiting = (0, import_react.useCallback)(normalize(onExiting), [onExiting]);
	const handleExited = (0, import_react.useCallback)(normalize(onExited), [onExited]);
	const handleAddEndListener = (0, import_react.useCallback)(normalize(addEndListener), [addEndListener]);
	return Object.assign({}, props, { nodeRef }, onEnter && { onEnter: handleEnter }, onEntering && { onEntering: handleEntering }, onEntered && { onEntered: handleEntered }, onExit && { onExit: handleExit }, onExiting && { onExiting: handleExiting }, onExited && { onExited: handleExited }, addEndListener && { addEndListener: handleAddEndListener }, { children: typeof children === "function" ? (status, innerProps) => children(status, Object.assign({}, innerProps, { ref: mergedRef })) : /* @__PURE__ */ (0, import_react.cloneElement)(children, { ref: mergedRef }) });
}

//#endregion
//#region node_modules/@restart/ui/esm/RTGTransition.js
var _excluded$1 = ["component"];
function _objectWithoutPropertiesLoose$1(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
var RTGTransition = /* @__PURE__ */ import_react.forwardRef((_ref, ref) => {
	let { component: Component } = _ref;
	const transitionProps = useRTGTransitionProps(_objectWithoutPropertiesLoose$1(_ref, _excluded$1));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, Object.assign({ ref }, transitionProps));
});
var RTGTransition_default = RTGTransition;

//#endregion
//#region node_modules/@restart/ui/esm/ImperativeTransition.js
function useTransition({ in: inProp, onTransition }) {
	const ref = (0, import_react.useRef)(null);
	const isInitialRef = (0, import_react.useRef)(true);
	const handleTransition = useEventCallback$1(onTransition);
	useIsomorphicEffect_default(() => {
		if (!ref.current) return;
		let stale = false;
		handleTransition({
			in: inProp,
			element: ref.current,
			initial: isInitialRef.current,
			isStale: () => stale
		});
		return () => {
			stale = true;
		};
	}, [inProp, handleTransition]);
	useIsomorphicEffect_default(() => {
		isInitialRef.current = false;
		return () => {
			isInitialRef.current = true;
		};
	}, []);
	return ref;
}
/**
* Adapts an imperative transition function to a subset of the RTG `<Transition>` component API.
*
* ImperativeTransition does not support mounting options or `appear` at the moment, meaning
* that it always acts like: `mountOnEnter={true} unmountOnExit={true} appear={true}`
*/
function ImperativeTransition({ children, in: inProp, onExited, onEntered, transition }) {
	const [exited, setExited] = (0, import_react.useState)(!inProp);
	if (inProp && exited) setExited(false);
	const combinedRef = useMergedRefs_default(useTransition({
		in: !!inProp,
		onTransition: (options) => {
			const onFinish = () => {
				if (options.isStale()) return;
				if (options.in) onEntered?.(options.element, options.initial);
				else {
					setExited(true);
					onExited?.(options.element);
				}
			};
			Promise.resolve(transition(options)).then(onFinish, (error) => {
				if (!options.in) setExited(true);
				throw error;
			});
		}
	}), getChildRef(children));
	return exited && !inProp ? null : /* @__PURE__ */ (0, import_react.cloneElement)(children, { ref: combinedRef });
}
function renderTransition(component, runTransition, props) {
	if (component) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RTGTransition_default, Object.assign({}, props, { component }));
	if (runTransition) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ImperativeTransition, Object.assign({}, props, { transition: runTransition }));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NoopTransition_default, Object.assign({}, props));
}

//#endregion
//#region node_modules/@restart/ui/esm/Modal.js
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom());
var _excluded = [
	"show",
	"role",
	"className",
	"style",
	"children",
	"backdrop",
	"keyboard",
	"onBackdropClick",
	"onEscapeKeyDown",
	"transition",
	"runTransition",
	"backdropTransition",
	"runBackdropTransition",
	"autoFocus",
	"enforceFocus",
	"restoreFocus",
	"restoreFocusOptions",
	"renderDialog",
	"renderBackdrop",
	"manager",
	"container",
	"onShow",
	"onHide",
	"onExit",
	"onExited",
	"onExiting",
	"onEnter",
	"onEntering",
	"onEntered"
];
function _objectWithoutPropertiesLoose(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
var manager;
function getManager(window$1) {
	if (!manager) manager = new ModalManager_default({ ownerDocument: window$1 == null ? void 0 : window$1.document });
	return manager;
}
function useModalManager(provided) {
	const window$1 = useWindow();
	const modalManager = provided || getManager(window$1);
	const modal = (0, import_react.useRef)({
		dialog: null,
		backdrop: null
	});
	return Object.assign(modal.current, {
		add: () => modalManager.add(modal.current),
		remove: () => modalManager.remove(modal.current),
		isTopModal: () => modalManager.isTopModal(modal.current),
		setDialogRef: (0, import_react.useCallback)((ref) => {
			modal.current.dialog = ref;
		}, []),
		setBackdropRef: (0, import_react.useCallback)((ref) => {
			modal.current.backdrop = ref;
		}, [])
	});
}
var Modal = /* @__PURE__ */ (0, import_react.forwardRef)((_ref, ref) => {
	let { show = false, role = "dialog", className, style, children, backdrop = true, keyboard = true, onBackdropClick, onEscapeKeyDown, transition, runTransition, backdropTransition, runBackdropTransition, autoFocus = true, enforceFocus = true, restoreFocus = true, restoreFocusOptions, renderDialog, renderBackdrop = (props) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", Object.assign({}, props)), manager: providedManager, container: containerRef, onShow, onHide = () => {}, onExit, onExited, onExiting, onEnter, onEntering, onEntered } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
	const ownerWindow = useWindow();
	const container = useWaitForDOMRef(containerRef);
	const modal = useModalManager(providedManager);
	const isMounted = useMounted();
	const prevShow = usePrevious(show);
	const [exited, setExited] = (0, import_react.useState)(!show);
	const lastFocusRef = (0, import_react.useRef)(null);
	(0, import_react.useImperativeHandle)(ref, () => modal, [modal]);
	if (canUseDOM_default && !prevShow && show) lastFocusRef.current = activeElement(ownerWindow == null ? void 0 : ownerWindow.document);
	if (show && exited) setExited(false);
	const handleShow = useEventCallback$1(() => {
		modal.add();
		removeKeydownListenerRef.current = listen_default(document, "keydown", handleDocumentKeyDown);
		removeFocusListenerRef.current = listen_default(document, "focus", () => setTimeout(handleEnforceFocus), true);
		if (onShow) onShow();
		if (autoFocus) {
			var _modal$dialog$ownerDo, _modal$dialog;
			const currentActiveElement = activeElement((_modal$dialog$ownerDo = (_modal$dialog = modal.dialog) == null ? void 0 : _modal$dialog.ownerDocument) != null ? _modal$dialog$ownerDo : ownerWindow == null ? void 0 : ownerWindow.document);
			if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {
				lastFocusRef.current = currentActiveElement;
				modal.dialog.focus();
			}
		}
	});
	const handleHide = useEventCallback$1(() => {
		modal.remove();
		removeKeydownListenerRef.current == null || removeKeydownListenerRef.current();
		removeFocusListenerRef.current == null || removeFocusListenerRef.current();
		if (restoreFocus) {
			var _lastFocusRef$current;
			(_lastFocusRef$current = lastFocusRef.current) == null || _lastFocusRef$current.focus == null || _lastFocusRef$current.focus(restoreFocusOptions);
			lastFocusRef.current = null;
		}
	});
	(0, import_react.useEffect)(() => {
		if (!show || !container) return;
		handleShow();
	}, [
		show,
		container,
		handleShow
	]);
	(0, import_react.useEffect)(() => {
		if (!exited) return;
		handleHide();
	}, [exited, handleHide]);
	useWillUnmount(() => {
		handleHide();
	});
	const handleEnforceFocus = useEventCallback$1(() => {
		if (!enforceFocus || !isMounted() || !modal.isTopModal()) return;
		const currentActiveElement = activeElement(ownerWindow == null ? void 0 : ownerWindow.document);
		if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) modal.dialog.focus();
	});
	const handleBackdropClick = useEventCallback$1((e) => {
		if (e.target !== e.currentTarget) return;
		onBackdropClick?.(e);
		if (backdrop === true) onHide();
	});
	const handleDocumentKeyDown = useEventCallback$1((e) => {
		if (keyboard && isEscKey(e) && modal.isTopModal()) {
			onEscapeKeyDown?.(e);
			if (!e.defaultPrevented) onHide();
		}
	});
	const removeFocusListenerRef = (0, import_react.useRef)();
	const removeKeydownListenerRef = (0, import_react.useRef)();
	const handleHidden = (...args) => {
		setExited(true);
		onExited?.(...args);
	};
	if (!container) return null;
	const dialogProps = Object.assign({
		role,
		ref: modal.setDialogRef,
		"aria-modal": role === "dialog" ? true : void 0
	}, rest, {
		style,
		className,
		tabIndex: -1
	});
	let dialog = renderDialog ? renderDialog(dialogProps) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", Object.assign({}, dialogProps, { children: /* @__PURE__ */ import_react.cloneElement(children, { role: "document" }) }));
	dialog = renderTransition(transition, runTransition, {
		unmountOnExit: true,
		mountOnEnter: true,
		appear: true,
		in: !!show,
		onExit,
		onExiting,
		onExited: handleHidden,
		onEnter,
		onEntering,
		onEntered,
		children: dialog
	});
	let backdropElement = null;
	if (backdrop) {
		backdropElement = renderBackdrop({
			ref: modal.setBackdropRef,
			onClick: handleBackdropClick
		});
		backdropElement = renderTransition(backdropTransition, runBackdropTransition, {
			in: !!show,
			appear: true,
			mountOnEnter: true,
			unmountOnExit: true,
			children: backdropElement
		});
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: /* @__PURE__ */ import_react_dom.createPortal(/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [backdropElement, dialog] }), container) });
});
Modal.displayName = "Modal";
var Modal_default = Object.assign(Modal, { Manager: ModalManager_default });

//#endregion
//#region node_modules/dom-helpers/esm/hasClass.js
/**
* Checks if a given element has a CSS class.
* 
* @param element the element
* @param className the CSS class name
*/
function hasClass(element, className) {
	if (element.classList) return !!className && element.classList.contains(className);
	return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

//#endregion
//#region node_modules/dom-helpers/esm/addClass.js
/**
* Adds a CSS class to a given element.
* 
* @param element the element
* @param className the CSS class name
*/
function addClass(element, className) {
	if (element.classList) element.classList.add(className);
	else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
	else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}

//#endregion
//#region node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
	return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
/**
* Removes a CSS class from a given element.
* 
* @param element the element
* @param className the CSS class name
*/
function removeClass(element, className) {
	if (element.classList) element.classList.remove(className);
	else if (typeof element.className === "string") element.className = replaceClassName(element.className, className);
	else element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
}

//#endregion
//#region node_modules/react-bootstrap/esm/BootstrapModalManager.js
var Selector = {
	FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
	STICKY_CONTENT: ".sticky-top",
	NAVBAR_TOGGLER: ".navbar-toggler"
};
var BootstrapModalManager = class extends ModalManager_default {
	adjustAndStore(prop, element, adjust) {
		const actual = element.style[prop];
		element.dataset[prop] = actual;
		css_default(element, { [prop]: `${parseFloat(css_default(element, prop)) + adjust}px` });
	}
	restore(prop, element) {
		const value = element.dataset[prop];
		if (value !== void 0) {
			delete element.dataset[prop];
			css_default(element, { [prop]: value });
		}
	}
	setContainerStyle(containerState) {
		super.setContainerStyle(containerState);
		const container = this.getElement();
		addClass(container, "modal-open");
		if (!containerState.scrollBarWidth) return;
		const paddingProp = this.isRTL ? "paddingLeft" : "paddingRight";
		const marginProp = this.isRTL ? "marginLeft" : "marginRight";
		qsa(container, Selector.FIXED_CONTENT).forEach((el) => this.adjustAndStore(paddingProp, el, containerState.scrollBarWidth));
		qsa(container, Selector.STICKY_CONTENT).forEach((el) => this.adjustAndStore(marginProp, el, -containerState.scrollBarWidth));
		qsa(container, Selector.NAVBAR_TOGGLER).forEach((el) => this.adjustAndStore(marginProp, el, containerState.scrollBarWidth));
	}
	removeContainerStyle(containerState) {
		super.removeContainerStyle(containerState);
		const container = this.getElement();
		removeClass(container, "modal-open");
		const paddingProp = this.isRTL ? "paddingLeft" : "paddingRight";
		const marginProp = this.isRTL ? "marginLeft" : "marginRight";
		qsa(container, Selector.FIXED_CONTENT).forEach((el) => this.restore(paddingProp, el));
		qsa(container, Selector.STICKY_CONTENT).forEach((el) => this.restore(marginProp, el));
		qsa(container, Selector.NAVBAR_TOGGLER).forEach((el) => this.restore(marginProp, el));
	}
};
var sharedManager;
function getSharedManager(options) {
	if (!sharedManager) sharedManager = new BootstrapModalManager(options);
	return sharedManager;
}
var BootstrapModalManager_default = BootstrapModalManager;

//#endregion
//#region node_modules/react-bootstrap/esm/ModalContext.js
var ModalContext = /* @__PURE__ */ import_react.createContext({ onHide() {} });
var ModalContext_default = ModalContext;

//#endregion
//#region node_modules/react-bootstrap/esm/AbstractModalHeader.js
var AbstractModalHeader = /* @__PURE__ */ import_react.forwardRef(({ closeLabel = "Close", closeVariant, closeButton = false, onHide, children, ...props }, ref) => {
	const context = (0, import_react.useContext)(ModalContext_default);
	const handleClick = useEventCallback(() => {
		context?.onHide();
		onHide?.();
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		ref,
		...props,
		children: [children, closeButton && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton_default, {
			"aria-label": closeLabel,
			variant: closeVariant,
			onClick: handleClick
		})]
	});
});
AbstractModalHeader.displayName = "AbstractModalHeader";
var AbstractModalHeader_default = AbstractModalHeader;

//#endregion
export { hasClass as a, useWaitForDOMRef as c, CloseButton_default as d, divWithClassName_default as f, getSharedManager as i, useWindow as l, useCommittedRef_default as m, ModalContext_default as n, Modal_default as o, useEventCallback as p, BootstrapModalManager_default as r, renderTransition as s, AbstractModalHeader_default as t, contains as u };
//# sourceMappingURL=AbstractModalHeader-Byup_DrD.js.map